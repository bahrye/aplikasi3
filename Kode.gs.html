/**
 * @fileoverview Backend untuk Aplikasi Input Nilai Madrasah.
 * Mengelola otentikasi, pengambilan data, dan penyimpanan nilai.
 * @version 2.11 (CRUD Guru Superadmin & Grouping)
 * @author Peningkatan Performa oleh Gemini, Fitur Kunci oleh Gemini
 * @description
 * Versi 2.11: Menambahkan fungsi Tambah, Edit, Hapus Guru untuk superadmin
 * dan mengelompokkan tampilan guru berdasarkan sekolah.
 */

// ID Spreadsheet "Aplikasi 2" (Pusat Login Global)
// (Diambil dari file aplikasi1/Kode.gs.html Anda)
const ID_SPREADSHEET_APLIKASI_2 = "1vNp3tvy9Ahy0apVBzcg7BClHsrJG85W3z-kSMjlzWuQ";
const ID_MASTER_SHEET_APLIKASI_1 = "191TzI0vRzK8xg7kGym8qUnvXz_edlCH_IJmmwMZMK_M";
// Konstanta Global untuk Akses Cepat ke Spreadsheet
const SS = SpreadsheetApp.openById(ID_SPREADSHEET_APLIKASI_2);
const GURU_SHEET = SS.getSheetByName('db_guru');
// const SISWA_SHEET = SS.getSheetByName('db_siswa');
const TAHUN_AJARAN_SHEET = SS.getSheetByName('db_tahun_ajaran');
// const ENROLLMENT_SHEET = SS.getSheetByName('db_enrollment');
// const MAPEL_SHEET = SS.getSheetByName('db_mapel');
const SEKOLAH_SHEET = SS.getSheetByName('db_sekolah');
// const PENGATURAN_CETAK_SHEET = SS.getSheetByName('db_pengaturan_cetak');
const STATUS_KIRIM_SHEET = SS.getSheetByName('db_status_kirim');
// ===== BARU: Sheet untuk Pengaturan Katrol Nilai =====
// const PENGATURAN_KATROL_SHEET = SS.getSheetByName('db_pengaturan_katrol');

// Cache untuk menyimpan referensi sheet yang sudah diakses agar tidak perlu dicari berulang kali.
const sheetCache = {};
// ===== BARU: Cache untuk Sheet Nilai Asli =====
const sheetCacheAsli = {};


/**
 * Mengubah array byte (dari computeDigest) menjadi string heksadesimal.
 */
function bytesToHex(bytes) {
  return bytes.map(byte => {
    return ('0' + (byte & 0xFF).toString(16)).slice(-2);
  }).join('');
}

/**
 * Membuat string salt acak yang unik.
 */
function generateSalt() {
  return Utilities.getUuid();
}

/**
 * Membuat hash SHA-256 dari password dan salt.
 * Mengembalikan hash sebagai string hex.
 */
function hashPassword(password, salt) {
  const digest = Utilities.computeDigest(Utilities.DigestAlgorithm.SHA_256, password + salt, Utilities.Charset.UTF_8);
  return bytesToHex(digest);
}

/**
 * Memverifikasi apakah password inputan cocok dengan hash yang tersimpan.
 */
function verifyPassword(inputPassword, storedHash, storedSalt) {
  const newHash = hashPassword(inputPassword, storedSalt);
  return newHash === storedHash;
}

/**
 * ===== BARU: Fungsi Helper Keamanan Superadmin =====
 * Mengecek apakah email yang diberikan memiliki peran 'superadmin'.
 * @param {string} email - Email pengguna.
 * @returns {boolean} True jika superadmin, false jika tidak.
 */
function isSuperadmin(email) {
  if (!email) return false;
  const dataGuru = GURU_SHEET.getDataRange().getValues();
  const userEmailLower = email.toLowerCase();

  for (let i = 1; i < dataGuru.length; i++) {
    const row = dataGuru[i];
    const sheetEmailLower = row[0].toLowerCase();
    
    if (sheetEmailLower === userEmailLower) {
      const role = row[4] || 'guru'; // Kolom E (index 4)
      return role.toLowerCase() === 'superadmin';
    }
  }
  return false;
}


/**
 * ===== HELPER (Langkah 5): Refactored =====
 * Mengecek status kunci dari DB sekolah yang spesifik.
 * @param {string} id_tahun_ajaran - ID unik dari tahun ajaran.
 * @param {Spreadsheet} ss_sekolah - Spreadsheet database sekolah.
 * @returns {boolean} True jika terkunci, false jika tidak.
 */
function isTahunAjaranLocked(id_tahun_ajaran, ss_sekolah) {
  const taSheet = ss_sekolah.getSheetByName('db_tahun_ajaran');
  if (!taSheet) return false; // Asumsikan tidak terkunci jika sheet tidak ada
  
  const taData = taSheet.getDataRange().getValues();
  for (let i = 1; i < taData.length; i++) {
    if (taData[i][0] == id_tahun_ajaran) {
      const statusKunci = taData[i][2];
      if (statusKunci === true || (typeof statusKunci === 'string' && statusKunci.toUpperCase() === 'TRUE')) {
        return true;
      }
    }
  }
  return false;
}

// DENGAN FUNGSI INI
function getNilaiSheetByTahunAjaran(id_tahun_ajaran, ss_sekolah) {
  
  const taSheet = ss_sekolah.getSheetByName('db_tahun_ajaran');
  if (!taSheet) throw new Error(`Sheet 'db_tahun_ajaran' tidak ditemukan di DB ${ss_sekolah.getId()}`);
  
  const taData = taSheet.getDataRange().getValues();
  let deskripsi = '';
  for (let i = 1; i < taData.length; i++) {
    if (taData[i][0] == id_tahun_ajaran) {
      deskripsi = taData[i][1];
      break;
    }
  }

  if (!deskripsi) {
    throw new Error(`Tahun Ajaran dengan ID "${id_tahun_ajaran}" tidak ditemukan.`);
  }

  const sheetName = `db_nilai_${deskripsi.replace('/', '-')}`;
  // --- (Akhir logika pencarian sheetName) ---
  
  let sheet = ss_sekolah.getSheetByName(sheetName);

  if (!sheet) {
    sheet = ss_sekolah.insertSheet(sheetName);
    // [MODIFIKASI] Mengganti "nilai" dengan "nilai_ujian" dan "nilai_praktek"
    const headers = [
      "id_nilai", "nomor_ujian", "mapel", "nilai_ujian", "nilai_praktek", "email_guru",
      "timestamp", "id_tahun_ajaran"
    ];
    sheet.appendRow(headers);
    // [MODIFIKASI] Range header sekarang A1:H1
    sheet.getRange("A1:H1").setFontWeight("bold");
    sheet.setFrozenRows(1);
    sheet.getRange("B:B").setNumberFormat('@'); // Format Teks
  } else {
    // Perbaikan otomatis untuk sheet yang sudah ada
    const header = sheet.getRange(1, 4).getValue();
    if (header === "nilai") {
      sheet.getRange(1, 4).setValue("nilai_ujian");
      sheet.getRange(1, 5).setValue("nilai_praktek");
      // Pindahkan data lama dari kolom 'email_guru' (E) ke 'email_guru' (F)
      const lastRow = sheet.getLastRow();
      if (lastRow > 1) {
         // Pindahkan E -> F, F -> G, G -> H
         sheet.getRange(2, 5, lastRow - 1, 3).moveTo(sheet.getRange(2, 6));
         // Hapus kolom E (nilai_praktek) yang sekarang kosong
         sheet.getRange(2, 5, lastRow - 1, 1).clearContent();
      }
      // Set header F, G, H
      sheet.getRange(1, 6).setValue("email_guru");
      sheet.getRange(1, 7).setValue("timestamp");
      sheet.getRange(1, 8).setValue("id_tahun_ajaran");
      Logger.log(`Skema db_nilai_... untuk ${sheetName} telah dimigrasi.`);
    }
  }

  return sheet;
}

/**
 * ===== HELPER (Langkah 5): Refactored & MODIFIED =====
 * Mengelola Sheet Nilai ASLI dari DB sekolah yang spesifik.
 * [MODIFIKASI] Diubah untuk mendukung nilai_asli_ujian dan nilai_asli_praktek.
 * @param {string} id_tahun_ajaran - ID unik dari tahun ajaran.
 * @param {Spreadsheet} ss_sekolah - Spreadsheet database sekolah.
 * @returns {Sheet} Objek Sheet 'db_nilai_asli_...'
 */
function getNilaiAsliSheetByTahunAjaran(id_tahun_ajaran, ss_sekolah) {
  const taSheet = ss_sekolah.getSheetByName('db_tahun_ajaran');
  if (!taSheet) throw new Error(`Sheet 'db_tahun_ajaran' tidak ditemukan di DB ${ss_sekolah.getId()}`);

  const taData = taSheet.getDataRange().getValues();
  let deskripsi = '';
  for (let i = 1; i < taData.length; i++) {
    if (taData[i][0] == id_tahun_ajaran) {
      deskripsi = taData[i][1];
      break;
    }
  }

  if (!deskripsi) {
    throw new Error(`Tahun Ajaran dengan ID "${id_tahun_ajaran}" tidak ditemukan.`);
  }

  const sheetName = `db_nilai_asli_${deskripsi.replace('/', '-')}`;
  let sheet = ss_sekolah.getSheetByName(sheetName);

  if (!sheet) {
    sheet = ss_sekolah.insertSheet(sheetName);
    // [MODIFIKASI] Header baru dengan 8 kolom
    const headers = [
      "id_nilai_asli", "nomor_ujian", "mapel", 
      "nilai_asli_ujian", "nilai_asli_praktek", // <-- Kolom baru
      "email_guru", "timestamp", "id_tahun_ajaran"
    ];
    sheet.appendRow(headers);
    sheet.getRange("A1:H1").setFontWeight("bold"); // <-- Update H1
    sheet.setFrozenRows(1);
    sheet.getRange("B:B").setNumberFormat('@'); // Format Teks
  } else {
    // [MODIFIKASI] Perbaikan otomatis untuk sheet yang sudah ada
    const header = sheet.getRange(1, 4).getValue();
    if (header === "nilai_asli") { // Cek header lama
      // 1. Ganti nama header lama
      sheet.getRange(1, 4).setValue("nilai_asli_ujian");
      // 2. Tambah header baru
      sheet.getRange(1, 5).setValue("nilai_asli_praktek");
      // 3. Pindahkan data lama (E, F, G) ke (F, G, H)
      const lastRow = sheet.getLastRow();
      if (lastRow > 1) {
         sheet.getRange(2, 5, lastRow - 1, 3).moveTo(sheet.getRange(2, 6));
         // Kosongkan kolom E (nilai_asli_praktek) yang sekarang kosong
         sheet.getRange(2, 5, lastRow - 1, 1).clearContent();
      }
      // 4. Set header baru (F, G, H)
      sheet.getRange(1, 6).setValue("email_guru");
      sheet.getRange(1, 7).setValue("timestamp");
      sheet.getRange(1, 8).setValue("id_tahun_ajaran");
      Logger.log(`Skema ${sheetName} telah dimigrasi ke Ujian/Praktek.`);
    }
  }

  return sheet;
}

// GANTI FUNGSI INI di aplikasi2/Kode.gs.html
function prosesOnetimeToken(ott) {
  if (!ott || !ott.startsWith('ott-')) {
    Logger.log("Proses OTT gagal: Token tidak valid.");
    return null;
  }
      
  const lock = LockService.getScriptLock();
  lock.waitLock(10000); 
  
  try {
    const ottSheet = getOttCacheSheet();
    const data = ottSheet.getDataRange().getValues();
    let payloadString = null; 
    let rowToDelete = -1;

    for (let i = data.length - 1; i >= 1; i--) {
      if (data[i][0] === ott) {
        payloadString = data[i][1]; 
        rowToDelete = i + 1; 
        break;
      }
    }
    
    if (rowToDelete > -1) {
      ottSheet.deleteRow(rowToDelete); 
    } else {
      Logger.log("Proses OTT gagal: Token tidak ditemukan atau kedaluwarsa.");
      return null; 
    }
    
    if (!payloadString) {
      Logger.log("Proses OTT gagal: Payload tidak ada.");
      return null;
    }

    let payload;
    try {
      payload = JSON.parse(payloadString);
    } catch (e) {
      Logger.log("Proses OTT gagal: Payload bukan JSON valid. Payload: " + payloadString);
      return null;
    }
    
    if (!payload.email || !payload.jenjangPilihan) {
      Logger.log("Proses OTT gagal: Payload tidak lengkap (email/jenjangPilihan tidak ada).");
      return null;
    }

    const email = payload.email.toLowerCase();
    const jenjangPilihan = payload.jenjangPilihan;
    
    // Cari id_sekolah dari db_guru (global)
    const dataGuru = GURU_SHEET.getDataRange().getValues();
    let id_sekolah = null;
    for (let i = 1; i < dataGuru.length; i++) {
      if (dataGuru[i][0].toLowerCase() === email) {
        id_sekolah = dataGuru[i][3]; // Kolom D
        break;
      }
    }
    if (!id_sekolah) {
      Logger.log(`Proses OTT gagal: Guru ${email} tidak ditemukan di db_guru global.`);
      return null;
    }
    
    // Ambil ID Database
    const dbIDs = _getSekolahDB_IDs(id_sekolah);

    // --- [MODIFIKASI LOGIKA SESI GANDA DIMULAI DI SINI] ---
    const properties = PropertiesService.getScriptProperties();
    const tokenKey = 'token_' + email;

    // 1. Cek apakah ada token LAMA
    const oldToken = properties.getProperty(tokenKey);
    
    if (oldToken) {
      // 2. Jika ada, HAPUS sesi lama
      const oldAuthKey = 'auth_' + oldToken;
      properties.deleteProperty(oldAuthKey);
      Logger.log(`Sesi lama untuk ${email} (Token: ${oldToken}) telah dihapus karena login baru (via OTT).`);
    }

    // 3. Buat token BARU (SELALU buat baru)
    const newToken = 'tok-' + Utilities.getUuid();
    const newAuthKey = 'auth_' + newToken;
    // --- [AKHIR MODIFIKASI LOGIKA SESI GANDA] ---
    
    const now = new Date().getTime();
    
    const authData = JSON.stringify({
      email: email,
      timestamp: now,
      jenjangPilihan: jenjangPilihan,
      id_sekolah: id_sekolah, // Simpan id_sekolah
      db_id: dbIDs.app2_db_id, // Simpan ID DB App 2
      app1_db_id: dbIDs.app1_db_id, // Simpan ID DB App 1
      pengumuman: payload.pengumuman || null // Simpan pengumuman jika ada
    });
    
    // 4. Simpan token BARU
    properties.setProperties({
      [tokenKey]: newToken,   // Simpan token BARU sebagai token aktif
      [newAuthKey]: authData // Simpan data sesi BARU
    });

    return newToken; // 5. Kembalikan token BARU

  } catch (e) {
    Logger.log("Error fatal saat proses OTT: " + e.message);
    return null;
  } finally {
    lock.releaseLock();
  }
}

/**
 * [FUNGSI INI TELAH DIMODIFIKASI UNTUK KEAMANAN V2]
 * Menangani permintaan GET.
 * - Jika 'ott' ada: Injeksi skrip untuk menyimpan token di localStorage DAN flag di sessionStorage.
 * - Jika 'ott' TIDAK ada: Tidak menginjeksi skrip apa pun, serahkan pada client.js.
 */
function doGet(e) {
  let token = null;

  // 1. Cek One-Time Token (OTT) dari Aplikasi 1
  if (e.parameter.ott) {
    token = prosesOnetimeToken(e.parameter.ott);
  }

  // 2. Buat output HTML
  const htmlTemplate = HtmlService.createTemplateFromFile('Index');
  const htmlOutput = htmlTemplate.evaluate() // Evaluasi template
    .setTitle('Input Nilai Ujian Madrasah')
    .setFaviconUrl("https://images.icon-icons.com/3310/PNG/512/teacher_man_user_avatar_school_icon_209258.png")
    .addMetaTag('viewport', 'width=device-width, initial-scale=1.0');

  // 3. Logika Injeksi Skrip
  if (token) {
    // KASUS 1: Login SSO (ada OTT)
    // Injeksi skrip untuk MENYIMPAN token DAN flag validitas tab
    const script = `<script>
                      try {
                        console.log("Menerima token SSO...");
                        // Simpan token sesi global
                        localStorage.setItem('authToken', '${token}');
                        
                        // [MODIFIKASI] Tandai TAB INI sebagai tab yang valid
                        sessionStorage.setItem('ssoOrigin', 'true');
                        
                        // Hapus parameter 'ott' dari URL agar tidak terlihat
                        window.history.replaceState({}, document.title, window.location.pathname);
                        
                        console.log("Token SSO dan flag sesi disimpan, memanggil checkSession...");
                        
                        if (typeof checkSession === 'function') {
                          checkSession();
                        } else {
                          window.location.reload();
                        }
                      } catch(e) {
                        console.error("Gagal memproses SSO:", e);
                        document.getElementById('login-view').style.display = 'flex';
                        document.getElementById('loading-view').style.display = 'none'; 
                      }
                    </script>`;
    
    htmlOutput.append(script);

  } else {
    
    // KASUS 2: Beban Halaman Langsung (tidak ada OTT) atau Refresh
    // TIDAK melakukan apa-apa. Biarkan client.js (checkSession)
    // yang memvalidasi berdasarkan token DAN flag sessionStorage.
  }
  
  // Izinkan aplikasi untuk dimuat di dalam iframe Google
  htmlOutput.setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL);

  return htmlOutput;
}

/**
 * [MODIFIED - DENGAN CACHE]
 * Mengambil data awal dengan sistem Cache 2 menit untuk mencegah Error 429.
 */
function getInitialDataForGuru(token) {
  try {
    // 1. Verifikasi sesi ringan dulu (tanpa buka sheet berat)
    const session = _getVerifiedSessionData(token, 'guru'); 
    const email = session.email;
    const id_sekolah = session.id_sekolah;

    // 2. CEK CACHE: Apakah data sudah ada di memori?
    const cache = CacheService.getScriptCache();
    const cacheKey = 'INIT_DATA_' + email + '_' + id_sekolah;
    const cachedData = cache.get(cacheKey);

    if (cachedData) {
      // Jika ada di cache, kembalikan langsung (Cepat & Hemat Kuota)
      return JSON.parse(cachedData);
    }

    // 3. JIKA TIDAK ADA DI CACHE: Baru baca Spreadsheet (Berat)
    const { ss_sekolah } = session; // Objek spreadsheet dari sesi
    
    // --- Logika Asli Pengambilan Data ---
    const taSheet = ss_sekolah.getSheetByName('db_tahun_ajaran');
    if (!taSheet) throw new Error("'db_tahun_ajaran' tidak ditemukan.");
    
    const taData = taSheet.getDataRange().getValues().slice(1);
    const allTahunAjaran = taData.map(row => {
      const statusKunci = row[2];
      return {
        id_tahun_ajaran: row[0],
        deskripsi: row[1],
        is_locked: (statusKunci === true || String(statusKunci).toUpperCase() === 'TRUE')
      };
    }).sort((a, b) => b.deskripsi.localeCompare(a.deskripsi));

    // Logika Mapel
    const mapelSheet = ss_sekolah.getSheetByName('db_mapel');
    if (!mapelSheet) throw new Error("'db_mapel' tidak ditemukan.");
    const mapelData = mapelSheet.getDataRange().getValues().slice(1);
    const guruMapelList = mapelData
      .filter(row => row[0].toLowerCase() === email.toLowerCase()) 
      .map(row => ({ id_tahun_ajaran: row[2], mapel: row[1] }));

    // Logika Status
    const statusSheet = getStatusKirimSheet(ss_sekolah);
    const statusData = statusSheet.getDataRange().getValues().slice(1);
    const sentStatusMap = statusData
      .filter(row => row[2].toLowerCase() === email.toLowerCase()) 
      .reduce((map, row) => {
        const key = `${row[1]}_${row[3]}`; 
        map.set(key, row[6]); 
        return map;
      }, new Map());

    const mapelWithStatus = guruMapelList.reduce((acc, item) => {
      const taId = item.id_tahun_ajaran;
      if (!acc[taId]) acc[taId] = [];
      const key = `${taId}_${item.mapel}`;
      acc[taId].push({
        mapel: item.mapel,
        status: sentStatusMap.get(key) || null
      });
      return acc;
    }, {});

    for (const taId in mapelWithStatus) {
        mapelWithStatus[taId].sort((a, b) => a.mapel.localeCompare(b.mapel));
    }

    const result = {
      tahunAjaran: allTahunAjaran,
      mapelWithStatus: mapelWithStatus
    };
    // ------------------------------------

    // 4. SIMPAN KE CACHE: Simpan hasil selama 120 detik (2 menit)
    // Data JSON mungkin besar, kita coba simpan. Jika terlalu besar, cache akan gagal diam-diam (tidak apa-apa).
    try {
      cache.put(cacheKey, JSON.stringify(result), 120); 
    } catch (e) {
      Logger.log("Data terlalu besar untuk cache, dilewati.");
    }

    return result;

  } catch (e) {
    Logger.log(`Error di getInitialDataForGuru: ${e.message}`);
    return { error: e.toString() };
  }
}

// GANTI FUNGSI INI di aplikasi2/Kode.gs.html
function userLogin(credentials) {
  if (!credentials || !credentials.email || !credentials.password) return null;

  const properties = PropertiesService.getScriptProperties();
  const dataGuru = GURU_SHEET.getDataRange().getValues();
  
  const sekolahData = SEKOLAH_SHEET.getDataRange().getValues();
  const sekolahPengumumanMap = sekolahData.slice(1).reduce((map, row) => {
    map[row[0]] = row[8] || null; // Kolom I (Pengumuman)
    return map;
  }, {});
  
  const userEmailLower = credentials.email.toLowerCase();

  for (let i = 1; i < dataGuru.length; i++) {
    const row = dataGuru[i];
    const sheetEmailLower = row[0].toLowerCase();

    if (sheetEmailLower === userEmailLower) {
      
      const storedHash = row[1]; // Kolom B (HashedPassword)
      const storedSalt = row[5]; // Kolom F (Salt)
      
      if (verifyPassword(credentials.password, storedHash, storedSalt)) {
        const email = row[0];
        const nama = row[2];
        const id_sekolah = row[3];
        const role = row[4] || 'guru';
        
        const pengumuman = (role !== 'superadmin' && sekolahPengumumanMap[id_sekolah]) 
                           ? sekolahPengumumanMap[id_sekolah] 
                           : null;
        
        // --- [MODIFIKASI LOGIKA SESI GANDA DIMULAI DI SINI] ---
        // 1. Cek apakah ada token LAMA
        const tokenKey = 'token_' + email.toLowerCase();
        const oldToken = properties.getProperty(tokenKey);

        if (oldToken) {
          // 2. Jika ada, HAPUS sesi lama
          const oldAuthKey = 'auth_' + oldToken;
          properties.deleteProperty(oldAuthKey);
          Logger.log(`Sesi lama untuk ${email} (Token: ${oldToken}) telah dihapus karena login baru (via form).`);
        }

        // 3. Buat token BARU (SELALU buat baru)
        const newToken = 'tok-' + Utilities.getUuid();
        const newAuthKey = 'auth_' + newToken;
        // --- [AKHIR MODIFIKASI LOGIKA SESI GANDA] ---

        const now = new Date().getTime();
        
        // --- (Logika pengambilan ID DB dan Notifikasi Anda tetap sama) ---
        let approvalStatusList = [];
        let db_id = null;
        let app1_db_id = null;
        let jenjangPilihan = null;
        
        if (role === 'guru' || role === 'superadmin') {
          try { 
            const dbIDs = _getSekolahDB_IDs(id_sekolah);
            db_id = dbIDs.app2_db_id;
            app1_db_id = dbIDs.app1_db_id;
            
            const ss_app1 = SpreadsheetApp.openById(app1_db_id);
            const dataSekolahSheet = ss_app1.getSheetByName('Data_Sekolah');
            if (dataSekolahSheet) {
              jenjangPilihan = dataSekolahSheet.getRange('A2').getValue() || null;
            }
            
            if (!jenjangPilihan) {
                throw new Error("Jenjang Pilihan (Data_Sekolah!A2) tidak diatur di database Aplikasi 1.");
            }
          } catch (e) {
            Logger.log(`GAGAL LOGIN: Gagal mengambil ID DB/Jenjang saat login untuk ${email}. Error: ${e.message}`);
            return null; 
          }
          
          if (role === 'guru') {
            try {
              const ss_sekolah = SpreadsheetApp.openById(db_id);
              const statusSheet = getStatusKirimSheet(ss_sekolah);
              const dataRange = statusSheet.getDataRange();
              const statusData = dataRange.getValues();
              let changesMade = false;
              
              for (let j = 1; j < statusData.length; j++) {
                // ... (logika notifikasi Anda) ...
              }
              if (changesMade) {
                dataRange.setValues(statusData);
                SpreadsheetApp.flush();
              }
            } catch (e) {
               Logger.log(`Gagal mengambil notifikasi status untuk ${email} (tidak fatal): ${e.message}`);
            }
          }
        }
        
        // 4. Simpan data sesi BARU
        const authData = JSON.stringify({
          email: email.toLowerCase(),
          timestamp: now,
          db_id: db_id,
          app1_db_id: app1_db_id,
          id_sekolah: id_sekolah,
          jenjangPilihan: jenjangPilihan,
          pengumuman: pengumuman
        });
        
        properties.setProperties({
          [tokenKey]: newToken,   // Simpan token BARU
          [newAuthKey]: authData // Simpan data sesi BARU
        });

        // 5. Kembalikan token BARU ke klien
        return {
          email: email,
          nama: nama,
          id_sekolah: role === 'superadmin' ? null : id_sekolah,
          token: newToken,
          role: role,
          pengumuman: pengumuman,
          jenjangPilihan: jenjangPilihan,
          approvalStatusList: approvalStatusList
        };
      }
    }
  }
  return null;
}

function verifyToken(token) {
  if (!token) return null;

  try {
    const session = _getVerifiedSessionData(token);

    return {
      email: session.email,
      nama: session.nama,
      id_sekolah: session.id_sekolah,
      token: token,
      role: session.role,
      pengumuman: (session.authData && session.authData.pengumuman) ? session.authData.pengumuman : null,
      jenjangPilihan: session.jenjangPilihan,
      approvalStatusList: session.approvalStatusList
    };
    
  } catch (e) {
    Logger.log(`verifyToken gagal: ${e.message}`);
    const properties = PropertiesService.getScriptProperties();
    const authKey = 'auth_' + token;
    properties.deleteProperty(authKey);
    return null;
  }
}

/**
 * [INTERNAL HELPER] Ambil Tahun Ajaran dari objek SS yang sudah terbuka
 */
function _getTahunAjaranInternal(ss_app2) {
    const sheet = getTahunAjaranSheet(ss_app2);
    if (sheet.getLastRow() <= 1) return { status: "sukses", data: [] };

    const data = sheet.getRange(2, 1, sheet.getLastRow() - 1, 3).getValues();
    
    // Cek penggunaan (Is Used)
    const statusSheet = ss_app2.getSheetByName('db_status_kirim');
    const usedIds = new Set();
    if (statusSheet && statusSheet.getLastRow() > 1) {
        statusSheet.getRange(2, 2, statusSheet.getLastRow()-1, 1).getValues().forEach(r => usedIds.add(r[0]));
    }
    
    const enrollSheet = getEnrollmentSheet_App2(ss_app2);
    if (enrollSheet && enrollSheet.getLastRow() > 1) {
        enrollSheet.getRange(2, 4, enrollSheet.getLastRow()-1, 1).getValues().forEach(r => usedIds.add(r[0]));
    }

    const list = data.map(row => ({
        id: row[0],
        deskripsi: row[1],
        isLocked: row[2] === true,
        isUsed: usedIds.has(row[0])
    })).filter(i => i.id);

    return { status: "sukses", data: list };
}

/**
 * [WRAPPER]
 */
function getTahunAjaran(token) {
    try {
        const dbId = getApp2DatabaseId(token);
        const ss = SpreadsheetApp.openById(dbId);
        return _getTahunAjaranInternal(ss);
    } catch (e) { return { status: "gagal", message: e.message }; }
}

/**
 * [OPTIMASI] Simpan TA tanpa membuka DB dua kali
 */
function saveTahunAjaran(token, dataToSave) {
    const lock = LockService.getDocumentLock();
    lock.waitLock(15000);
    try {
        const dbId = getApp2DatabaseId(token);
        const ss = SpreadsheetApp.openById(dbId);
        
        // Reuse SS yang sama
        const currentResponse = _getTahunAjaranInternal(ss);
        const currentMap = new Map(currentResponse.data.map(t => [t.id, t]));
        const newIdSet = new Set();
        const finalRows = [];

        // Validasi & Build Data
        for (const item of dataToSave) {
             if (!item.id || !item.deskripsi) throw new Error("ID/Deskripsi kosong.");
             if (newIdSet.has(item.id.toUpperCase())) throw new Error("ID Duplikat.");
             newIdSet.add(item.id.toUpperCase());

             const exist = currentMap.get(item.id);
             if (exist && exist.isUsed && !item.isLocked && exist.isLocked) {
                 // User trying to unlock used TA (Optional: Allow or Deny)
             }
             finalRows.push([item.id, item.deskripsi, item.isLocked === true]);
        }

        // Write
        const sheet = getTahunAjaranSheet(ss);
        if (sheet.getLastRow() > 1) sheet.deleteRows(2, sheet.getLastRow() - 1);
        if (finalRows.length > 0) sheet.getRange(2, 1, finalRows.length, 3).setValues(finalRows);

        return { status: "sukses" };
    } catch (e) { return { status: "gagal", message: e.message }; }
    finally { lock.releaseLock(); }
}

/**
 * [TEROPTIMASI SOLUSI A + B + C + E + Fitur Baru]
 * Logika inti mengambil nilai dengan pengecekan data Katrol.
 */
function _getSiswaAndNilaiInternal(ss_sekolah, id_sekolah, email_guru, nama_mapel, id_tahun_ajaran, requestID, filterKelas, filterNama) {
  
  // --- [TAMBAHAN: BACA IZIN DARI APP 1] ---
  let izinInput = { canSave: true, canSend: true, pesan: "", statusColor: "info" };
  try {
      const dbIDs = _getSekolahDB_IDs(id_sekolah); 
      if (dbIDs && dbIDs.app1_db_id) {
         izinInput = _getIzinInputDariApp1(dbIDs.app1_db_id);
      }
  } catch(e) {
      Logger.log("Error cek izin input guru: " + e);
  }
  // --- [AKHIR TAMBAHAN] ---

  // --- [OPTIMASI SOLUSI B: PENCARIAN MAPEL via CACHE] ---
  const cachedMapelList = getCachedMapelDb(ss_sekolah);
  
  let showUS = false;
  let showUP = false;
  let kelasJsonFilter = '["*"]';

  const targetMapel = cachedMapelList.find(item => 
    item.mapel == nama_mapel && 
    item.ta == id_tahun_ajaran && 
    item.email === email_guru.toLowerCase()
  );

  if (targetMapel) {
    showUS = targetMapel.isUS;
    showUP = targetMapel.isUP;
    kelasJsonFilter = targetMapel.kelasJson;
  } else {
    showUS = true; 
  }
  
  const kelasDiizinkan = JSON.parse(kelasJsonFilter);
  const bolehSemuaKelas = kelasDiizinkan.includes("*");
  // --- [AKHIR OPTIMASI B] ---

  // --- [OPTIMASI SOLUSI E: BACA DATA TA SEKALI SAJA] ---
  const taSheet = ss_sekolah.getSheetByName('db_tahun_ajaran');
  if (!taSheet) throw new Error("Database Tahun Ajaran tidak ditemukan.");
  
  const taData = taSheet.getDataRange().getValues();
  let isLocked = false;
  let taDeskripsi = '';
  let taFound = false;

  for (let i = 1; i < taData.length; i++) {
    if (String(taData[i][0]) == String(id_tahun_ajaran)) {
       taDeskripsi = taData[i][1];
       const status = taData[i][2];
       isLocked = (status === true || String(status).toUpperCase() === 'TRUE');
       taFound = true;
       break;
    }
  }

  if (!taFound) throw new Error("Tahun Ajaran tidak ditemukan.");
  
  // --- [BARU] CEK KETERSEDIAAN DATA KATROL (NILAI ASLI) ---
  // Kita cek apakah sheet Nilai Asli ada dan memiliki data untuk mapel ini
  let hasKatrolData = false;
  try {
      const sheetNameAsli = `db_nilai_asli_${taDeskripsi.replace('/', '-')}`;
      const sheetAsli = ss_sekolah.getSheetByName(sheetNameAsli);
      if (sheetAsli) {
          const dataAsli = sheetAsli.getDataRange().getValues();
          // Loop data (mulai baris 2) untuk mencari mapel & guru ini
          for(let i=1; i<dataAsli.length; i++) {
              // Kolom C (idx 2) = Mapel, Kolom F (idx 5) = Email Guru
              if (dataAsli[i][2] == nama_mapel && String(dataAsli[i][5]).toLowerCase() === email_guru.toLowerCase()) {
                  // Cek apakah Ujian (D/3) atau Praktek (E/4) terisi
                  const valU = dataAsli[i][3];
                  const valP = dataAsli[i][4];
                  if ( (valU !== "" && valU != null) || (valP !== "" && valP != null) ) {
                      hasKatrolData = true;
                      break; // Sudah ketemu minimal 1 data, cukup.
                  }
              }
          }
      }
  } catch (e) {
      Logger.log("Gagal cek data katrol: " + e);
  }
  // --- [AKHIR CEK DATA KATROL] ---

  // Konstruksi nama sheet nilai resmi
  const sheetName = `db_nilai_${taDeskripsi.replace('/', '-')}`;
  let NILAI_SHEET = ss_sekolah.getSheetByName(sheetName);
  
  if (!NILAI_SHEET) {
    NILAI_SHEET = getNilaiSheetByTahunAjaran(id_tahun_ajaran, ss_sekolah);
  }
  // --- [AKHIR OPTIMASI E] ---
  
  const enrollmentData = ss_sekolah.getSheetByName('db_enrollment').getDataRange().getValues().slice(1);
  
  const siswaListCached = getCachedSiswaData(ss_sekolah);
  const masterSiswaMap = {};
  for (let i = 0; i < siswaListCached.length; i++) {
    const s = siswaListCached[i];
    masterSiswaMap[s.no] = { nama: s.nama, nisn: s.nisn, kelas: s.kelas, originalIndex: s.idx };
  }

  const enrolledSiswa = enrollmentData
    .filter(row => {
      if (String(row[2]) != String(id_sekolah) || String(row[3]) != String(id_tahun_ajaran)) return false;
      const dataSiswa = masterSiswaMap[row[1]];
      if (!dataSiswa) return false;
      
      if (!bolehSemuaKelas && !kelasDiizinkan.includes(dataSiswa.kelas)) return false;
      if (filterKelas && filterKelas !== 'semua' && dataSiswa.kelas !== filterKelas) return false;
      if (filterNama && !dataSiswa.nama.toLowerCase().includes(filterNama.toLowerCase())) return false;
      return true;
    })
    .map(row => {
      const dataSiswa = masterSiswaMap[row[1]];
      return {
        nomor_ujian: row[1],
        ruang_ujian: row[4] || 'N/A',
        nama: dataSiswa.nama,
        nisn: dataSiswa.nisn,
        kelas: dataSiswa.kelas,
        originalIndex: dataSiswa.originalIndex
      };
    });

  if (enrolledSiswa.length === 0) {
    return { 
      siswaData: [], showUS: showUS, showUP: showUP, 
      requestID: requestID, isSudahKirim: false, 
      isTahunAjaranLocked: isLocked, allKelas: [],
      izinInput: izinInput,
      hasKatrolData: hasKatrolData // Tetap kirim status ini
    };
  }
  
  const allKelasSet = new Set(enrolledSiswa.map(s => s.kelas));
  const allKelasUnik = Array.from(allKelasSet).sort(compareKelas); 

  const nilaiData = NILAI_SHEET.getDataRange().getValues().slice(1);
  const nilaiMap = {};
  for (let i = 0; i < nilaiData.length; i++) {
    if (nilaiData[i][2] == nama_mapel) {
       nilaiMap[nilaiData[i][1]] = { ujian: nilaiData[i][3], praktek: nilaiData[i][4] };
    }
  }

  const result = enrolledSiswa.map(item => {
    const nilaiEntry = nilaiMap[item.nomor_ujian];
    return {
      ...item,
      nilai_ujian: (nilaiEntry && nilaiEntry.ujian !== "" && nilaiEntry.ujian !== undefined) ? nilaiEntry.ujian : (nilaiEntry && nilaiEntry.ujian === 0 ? 0 : ""),
      nilai_praktek: (nilaiEntry && nilaiEntry.praktek !== "" && nilaiEntry.praktek !== undefined) ? nilaiEntry.praktek : (nilaiEntry && nilaiEntry.praktek === 0 ? 0 : "")
    };
  }).sort((a, b) => {
    const classCmp = compareKelas(a.kelas, b.kelas);
    return classCmp !== 0 ? classCmp : a.originalIndex - b.originalIndex;
  });
  
  const keyCek = `${id_tahun_ajaran}_${email_guru.toLowerCase()}_${nama_mapel}`;
  const statusSheet = getStatusKirimSheet(ss_sekolah);
  const statusData = statusSheet.getDataRange().getValues();
  
  let statusKirim = null;
  let alasanTolak = null; // <--- [BARU] Variabel untuk alasan
  
  for (let i = 1; i < statusData.length; i++) {
      if (statusData[i][0] === keyCek) {
          statusKirim = statusData[i][6]; 
          alasanTolak = statusData[i][7]; // <--- [BARU] Ambil kolom H (Index 7)
          break;
      }
  }

  const isSudahKirim = (statusKirim === 'PENDING' || statusKirim === 'APPROVED' || statusKirim === 'APPROVED_NOTIFIED');

  return { 
    siswaData: result, 
    showUS: showUS, 
    showUP: showUP, 
    requestID: requestID, 
    statusKirim: statusKirim, 
    alasanTolak: alasanTolak, // <--- [BARU] Sertakan dalam return object
    isSudahKirim: isSudahKirim, 
    isTahunAjaranLocked: isLocked, 
    allKelas: allKelasUnik,
    izinInput: izinInput,
    hasKatrolData: hasKatrolData 
  };
}

/**
 * [WRAPPER] Fungsi Publik untuk Client
 */
function getSiswaAndNilai(token, id_sekolah_klien, nama_mapel, id_tahun_ajaran, requestID, email_guru_klien, filterKelas, filterNama) {
  try {
    const session = _getVerifiedSessionData(token, 'guru');
    // Panggil internal helper dengan sesi yang sudah terbuka
    return _getSiswaAndNilaiInternal(
      session.ss_sekolah, session.id_sekolah, session.email, 
      nama_mapel, id_tahun_ajaran, requestID, filterKelas, filterNama
    );
  } catch (e) {
    Logger.log(`Error getSiswaAndNilai: ${e.message}`);
    return { siswaData: [], requestID: requestID, isSudahKirim: false, isTahunAjaranLocked: true, error: e.message, allKelas: [] };
  }
}

/**
 * [TEROPTIMASI: SOLUSI A + B + C + E]
 * Mengambil data siswa dan nilai ASLI (Bahan Katrol).
 * Menggunakan Cache Mapel, Cache Siswa, dan Pembacaan TA Tunggal.
 */
function getSiswaAndNilaiAsli(token, id_sekolah_dari_klien, nama_mapel, id_tahun_ajaran, requestID, filterKelas, filterNama) {
  try {
    // 1. Dapatkan sesi (Ini membuka Spreadsheet sekali saja)
    const session = _getVerifiedSessionData(token, 'guru');
    const { ss_sekolah, id_sekolah, email } = session;

    // --- [OPTIMASI SOLUSI B] ---
    const cachedMapelList = getCachedMapelDb(ss_sekolah);
    
    let showUS = false;
    let showUP = false;
    let kelasJsonFilter = '["*"]';

    const targetMapel = cachedMapelList.find(item => 
      item.mapel == nama_mapel && 
      item.ta == id_tahun_ajaran && 
      item.email === email.toLowerCase()
    );

    if (targetMapel) {
      showUS = targetMapel.isUS;
      showUP = targetMapel.isUP;
      kelasJsonFilter = targetMapel.kelasJson;
    } else {
      showUS = true; 
    }
    
    const kelasDiizinkan = JSON.parse(kelasJsonFilter);
    const bolehSemuaKelas = kelasDiizinkan.includes("*");
    // --- [AKHIR OPTIMASI B] ---

    // --- [OPTIMASI SOLUSI E: BACA DATA TA SEKALI SAJA] ---
    const taSheet = ss_sekolah.getSheetByName('db_tahun_ajaran');
    if (!taSheet) throw new Error("Database Tahun Ajaran tidak ditemukan.");

    const taData = taSheet.getDataRange().getValues();
    let isLocked = false;
    let taDeskripsi = '';
    let taFound = false;

    for (let i = 1; i < taData.length; i++) {
      if (String(taData[i][0]) == String(id_tahun_ajaran)) {
         taDeskripsi = taData[i][1];
         const status = taData[i][2];
         isLocked = (status === true || String(status).toUpperCase() === 'TRUE');
         taFound = true;
         break;
      }
    }

    if (!taFound) throw new Error("Tahun Ajaran tidak ditemukan.");

    // Konstruksi nama sheet nilai ASLI (Format: db_nilai_asli_2024-2025)
    const sheetName = `db_nilai_asli_${taDeskripsi.replace('/', '-')}`;
    
    // Coba ambil sheet langsung (Fast Path)
    let NILAI_ASLI_SHEET = ss_sekolah.getSheetByName(sheetName);
    
    // Jika belum ada, panggil helper berat
    if (!NILAI_ASLI_SHEET) {
      NILAI_ASLI_SHEET = getNilaiAsliSheetByTahunAjaran(id_tahun_ajaran, ss_sekolah);
    }
    // --- [AKHIR OPTIMASI E] ---

    // 4. Baca data 'db_enrollment'
    const enrollmentData = ss_sekolah.getSheetByName('db_enrollment').getDataRange().getValues().slice(1);

    // 5. [OPTIMASI SOLUSI A]
    const siswaListCached = getCachedSiswaData(ss_sekolah);
    const masterSiswaMap = {};
    for (let i = 0; i < siswaListCached.length; i++) {
      const s = siswaListCached[i];
      masterSiswaMap[s.no] = {
        nama: s.nama,
        nisn: s.nisn,
        kelas: s.kelas,
        originalIndex: s.idx
      };
    }

    // 6. Filter siswa
    const enrolledSiswa = enrollmentData
      .filter(row => {
        if (String(row[2]) != String(id_sekolah) || String(row[3]) != String(id_tahun_ajaran)) return false;

        const no_ujian = row[1];
        const dataSiswa = masterSiswaMap[no_ujian];
        if (!dataSiswa) return false; 

        if (!bolehSemuaKelas && !kelasDiizinkan.includes(dataSiswa.kelas)) return false;
        if (filterKelas && filterKelas !== 'semua' && dataSiswa.kelas !== filterKelas) return false;
        if (filterNama && !dataSiswa.nama.toLowerCase().includes(filterNama.toLowerCase())) return false;

        return true;
      })
      .map(row => {
        const no_ujian = row[1];
        const dataSiswa = masterSiswaMap[no_ujian];
        return {
          nomor_ujian: no_ujian,
          ruang_ujian: row[4] || 'N/A',
          nama: dataSiswa.nama,
          nisn: dataSiswa.nisn,
          kelas: dataSiswa.kelas,
          originalIndex: dataSiswa.originalIndex
        };
      });

    if (enrolledSiswa.length === 0) {
      return { 
        siswaData: [], showUS: showUS, showUP: showUP, 
        requestID: requestID, isTahunAjaranLocked: isLocked, allKelas: [] 
      };
    }

    const allKelasSet = new Set(enrolledSiswa.map(s => s.kelas));
    const allKelasUnik = Array.from(allKelasSet).sort(compareKelas); 

    // 7. Baca Nilai Asli
    const nilaiData = NILAI_ASLI_SHEET.getDataRange().getValues().slice(1);
    const nilaiMap = {};
    
    for (let i = 0; i < nilaiData.length; i++) {
      const row = nilaiData[i];
      if (row[2] == nama_mapel) {
         nilaiMap[row[1]] = { ujian: row[3], praktek: row[4] };
      }
    }

    // 8. Gabungkan
    const result = enrolledSiswa.map(item => {
      const nilaiEntry = nilaiMap[item.nomor_ujian];
      const nilaiUjianMentah = nilaiEntry ? nilaiEntry.ujian : undefined;
      const nilaiPraktekMentah = nilaiEntry ? nilaiEntry.praktek : undefined;

      return {
        nomor_ujian: item.nomor_ujian,
        ruang_ujian: item.ruang_ujian,
        nama: item.nama,
        nisn: item.nisn,
        kelas: item.kelas,
        originalIndex: item.originalIndex, 
        
        nilai_asli_ujian: (nilaiUjianMentah === 0 ? 0 : (nilaiUjianMentah || '')),
        nilai_asli_praktek: (nilaiPraktekMentah === 0 ? 0 : (nilaiPraktekMentah || ''))
      };
    })
    .sort((a, b) => {
      const compareKelasVal = compareKelas(a.kelas, b.kelas);
      if (compareKelasVal !== 0) return compareKelasVal;
      return a.originalIndex - b.originalIndex;
    });

    // 9. Return
    return { 
      siswaData: result, 
      showUS: showUS,       
      showUP: showUP,       
      requestID: requestID, 
      isSudahKirim: false, 
      isTahunAjaranLocked: isLocked, 
      allKelas: allKelasUnik 
    };
    
  } catch (e) {
    Logger.log(`Error di getSiswaAndNilaiAsli: ${e.message}`);
    return { siswaData: [], showUS: true, showUP: false, requestID: requestID, isTahunAjaranLocked: true, error: e.message, allKelas: [] };
  }
}

// DENGAN FUNGSI INI
function simpanAtauUpdateNilai(token, dataNilai) {
  try {
    // 1. Dapatkan sesi dan DB sekolah
    const { ss_sekolah } = _getVerifiedSessionData(token, 'guru');
    
    if (!dataNilai || dataNilai.length === 0) return "Error: Tidak ada data untuk diproses.";
    const { id_tahun_ajaran } = dataNilai[0];

    // 2. Panggil helper dengan 'ss_sekolah'
    if (isTahunAjaranLocked(id_tahun_ajaran, ss_sekolah)) {
      return "Error: Gagal menyimpan. Tahun Ajaran ini telah dikunci dan tidak dapat diubah lagi.";
    }

    const { mapel, emailGuru } = dataNilai[0];
    const NILAI_SHEET = getNilaiSheetByTahunAjaran(id_tahun_ajaran, ss_sekolah);
    
    // 3. Modifikasi Logika Simpan (Batch)
    const range = NILAI_SHEET.getDataRange();
    const allNilai = range.getValues(); // Baca semua data SEKALI
    
    // Buat Peta: "NoUjian_Mapel" -> index baris (0-based)
    const existingDataMap = allNilai.reduce((map, row, index) => {
      if (index > 0) { // Lewati header
        const key = `${row[1]}_${row[2]}`; // Kolom B (no_ujian) + Kolom C (mapel)
        map[key] = index; // Simpan 0-based index
      }
      return map;
    }, {});

    let updatedCount = 0, insertedCount = 0, deletedCount = 0;
    const rowsToAppend = []; // Tampung baris baru di sini
    const now = new Date();

    dataNilai.forEach(item => {
      const key = `${item.nomorUjian}_${mapel}`;
      const rowIndex_0based = existingDataMap[key];
      
      const nilaiUjianFilled = item.nilai_ujian !== '' && item.nilai_ujian !== null;
      const nilaiPraktekFilled = item.nilai_praktek !== '' && item.nilai_praktek !== null;
      const nilaiIsFilled = nilaiUjianFilled || nilaiPraktekFilled;

      if (rowIndex_0based !== undefined) {
        // === UPDATE ===
        // Modifikasi array di memori, bukan di sheet
        allNilai[rowIndex_0based][3] = item.nilai_ujian;    // Kolom D (nilai_ujian)
        allNilai[rowIndex_0based][4] = item.nilai_praktek;  // Kolom E (nilai_praktek)
        allNilai[rowIndex_0based][6] = now;                 // Kolom G (timestamp)
        
        nilaiIsFilled ? updatedCount++ : deletedCount++;
        
      } else if (nilaiIsFilled) {
        // === INSERT ===
        // Kumpulkan baris baru di array
        rowsToAppend.push([
          new Date().getTime(), "'" + item.nomorUjian, mapel, 
          item.nilai_ujian, item.nilai_praktek, // Kolom D dan E
          emailGuru, now, id_tahun_ajaran         // Kolom F, G, H
        ]);
        // Tambahkan ke map agar tidak duplikat jika ada di dataToSave
        existingDataMap[key] = allNilai.length + rowsToAppend.length - 1; 
        insertedCount++;
      }
    });

    // 4. Tulis perubahan ke Sheet SETELAH loop selesai
    if (updatedCount > 0 || deletedCount > 0) {
      range.setValues(allNilai); // Tulis SEMUA data (termasuk yang diupdate) SEKALI
    }
    
    if (insertedCount > 0) {
      NILAI_SHEET.getRange(NILAI_SHEET.getLastRow() + 1, 1, rowsToAppend.length, 8)
                 .setValues(rowsToAppend); // Tulis SEMUA baris baru SEKALI
    }

    SpreadsheetApp.flush();
    const totalProcessed = updatedCount + insertedCount + deletedCount;
    return `Sukses! ${totalProcessed} data diproses (${insertedCount} baru, ${updatedCount} diperbarui, ${deletedCount} dikosongkan).`;
    
  } catch (e) {
    Logger.log(`Error di simpanAtauUpdateNilai: ${e.message}`);
    return `Error: ${e.message}`;
  }
}

function simpanAtauUpdateNilaiAsli(token, dataNilai) {
  try {
    // 1. Dapatkan sesi dan DB sekolah
    const { ss_sekolah } = _getVerifiedSessionData(token, 'guru');

    if (!dataNilai || dataNilai.length === 0) return "Error: Tidak ada data untuk diproses.";
    const { id_tahun_ajaran } = dataNilai[0];

    // 2. Cek kunci T.A.
    if (isTahunAjaranLocked(id_tahun_ajaran, ss_sekolah)) {
      return "Error: Gagal menyimpan. Tahun Ajaran ini telah dikunci.";
    }

    const { mapel, emailGuru } = dataNilai[0];
    const NILAI_ASLI_SHEET = getNilaiAsliSheetByTahunAjaran(id_tahun_ajaran, ss_sekolah);

    // 3. Modifikasi Logika Simpan (Batch)
    const range = NILAI_ASLI_SHEET.getDataRange();
    const allNilai = range.getValues(); // Baca semua data SEKALI
    
    // Buat map (Kunci: "NoUjian_Mapel", Value: index baris 0-based)
    const existingDataMap = allNilai.reduce((map, row, index) => {
      if (index > 0) { // Lewati header
        const key = `${row[1]}_${row[2]}`; // Kolom B (no_ujian) + Kolom C (mapel)
        map[key] = index; // Simpan 0-based index
      }
      return map;
    }, {});

    let updatedCount = 0, insertedCount = 0, deletedCount = 0;
    const rowsToAppend = []; // Tampung baris baru
    const now = new Date();

    dataNilai.forEach(item => {
      const key = `${item.nomorUjian}_${mapel}`;
      const rowIndex_0based = existingDataMap[key];

      // Cek apakah salah satu nilai diisi
      const nilaiUjianFilled = item.nilai_asli_ujian !== '' && item.nilai_asli_ujian !== null;
      const nilaiPraktekFilled = item.nilai_asli_praktek !== '' && item.nilai_asli_praktek !== null;
      const nilaiIsFilled = nilaiUjianFilled || nilaiPraktekFilled;

      if (rowIndex_0based !== undefined) {
        // === UPDATE ===
        // Modifikasi array di memori
        allNilai[rowIndex_0based][3] = item.nilai_asli_ujian;   // Kolom D (nilai_asli_ujian)
        allNilai[rowIndex_0based][4] = item.nilai_asli_praktek; // Kolom E (nilai_asli_praktek)
        allNilai[rowIndex_0based][6] = now;                      // Kolom G (timestamp)

        nilaiIsFilled ? updatedCount++ : deletedCount++;
      } else if (nilaiIsFilled) {
        // === INSERT ===
        // Kumpulkan baris baru di array
        rowsToAppend.push([
          new Date().getTime(), "'" + item.nomorUjian, mapel, 
          item.nilai_asli_ujian, item.nilai_asli_praktek, // Kolom D, E
          emailGuru, now, id_tahun_ajaran                 // Kolom F, G, H
        ]);
        // Tambahkan ke map agar tidak duplikat
        existingDataMap[key] = allNilai.length + rowsToAppend.length - 1; 
        insertedCount++;
      }
    });

    // 4. Tulis perubahan ke Sheet SETELAH loop selesai
    if (updatedCount > 0 || deletedCount > 0) {
      range.setValues(allNilai); // Tulis SEMUA data (termasuk yang diupdate) SEKALI
    }
    
    if (insertedCount > 0) {
      NILAI_ASLI_SHEET.getRange(NILAI_ASLI_SHEET.getLastRow() + 1, 1, rowsToAppend.length, 8)
                      .setValues(rowsToAppend); // Tulis SEMUA baris baru SEKALI
    }

    const totalProcessed = updatedCount + insertedCount + deletedCount;
    return `Sukses! ${totalProcessed} data nilai asli diproses.`;

  } catch (e) {
    Logger.log(`Error di simpanAtauUpdateNilaiAsli: ${e.message}`);
    return `Error: ${e.message}`;
  }
}

function kirimStatusNilai(token, data) {
  try {
    // 1. Dapatkan sesi (termasuk nama guru untuk email dan ID App 1)
    const { ss_sekolah, id_sekolah, email, nama, app1_db_id } = _getVerifiedSessionData(token, 'guru');
    
    const { id_tahun_ajaran, nama_mapel } = data;

    // 2. Cek apakah Tahun Ajaran Terkunci di DB Sekolah (App 2)
    if (isTahunAjaranLocked(id_tahun_ajaran, ss_sekolah)) {
      return { success: false, error: "Gagal mengirim. Tahun Ajaran ini telah dikunci." };
    }

    // --- [TAMBAHAN BARU: Validasi Izin Input dari App 1] ---
    // Mengecek apakah Admin di App 1 menonaktifkan tombol 'Kirim'
    const izinInput = _getIzinInputDariApp1(app1_db_id);
    if (!izinInput.canSend) {
       return { success: false, error: "Gagal mengirim: " + (izinInput.pesan || "Izin kirim nilai dinonaktifkan oleh Admin.") };
    }
    // --- [AKHIR TAMBAHAN] ---
    
    // 3. Ambil Pengaturan Cetak untuk tanggal
    const pengaturan = getPengaturanCetak(token, email, id_sekolah);
    let tanggal_to_save;

    if (pengaturan.preferensi_tanggal === 'manual' && pengaturan.tanggal_manual) {
      const parts = pengaturan.tanggal_manual.split('-');
      tanggal_to_save = new Date(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1, parseInt(parts[2], 10));
    } else {
      tanggal_to_save = new Date();
    }
    
    // 4. Simpan Status ke 'db_status_kirim'
    const STATUS_KIRIM_SHEET = getStatusKirimSheet(ss_sekolah);

    const key = `${id_tahun_ajaran}_${email.toLowerCase()}_${nama_mapel}`;
    const statusData = STATUS_KIRIM_SHEET.getDataRange().getValues();
    let rowToUpdate = -1;
    
    for (let i = 1; i < statusData.length; i++) {
      if (statusData[i][0] === key) {
        rowToUpdate = i + 1;
        break;
      }
    }

    // [Key, ID TA, Email, Mapel, Timestamp Kirim, Tgl Cetak, Status, Alasan]
    const newRowData = [key, id_tahun_ajaran, email, nama_mapel, new Date(), tanggal_to_save, "PENDING", ""];

    if (rowToUpdate > -1) {
      STATUS_KIRIM_SHEET.getRange(rowToUpdate, 1, 1, newRowData.length).setValues([newRowData]);
    } else {
      STATUS_KIRIM_SHEET.appendRow(newRowData);
    }
    
    // --- LOGIKA EMAIL OTOMATIS ---
    // Jalankan di dalam try-catch terpisah agar jika email gagal, status tetap tersimpan.
    try {
      // A. Ambil Email Admin
      const adminEmail = _getAdminEmailFromMaster(id_sekolah);
      
      // Ambil deskripsi TA untuk email yang lebih jelas
      const taSheet = ss_sekolah.getSheetByName('db_tahun_ajaran');
      const taData = taSheet.getDataRange().getValues();
      const taRow = taData.find(r => r[0] == id_tahun_ajaran);
      const deskripsiTA = taRow ? taRow[1] : id_tahun_ajaran;

      // B. Email ke ADMIN SEKOLAH
      if (adminEmail) {
        const subjectAdmin = `[Nilai Masuk] ${nama_mapel} - ${nama}`;
        const bodyAdmin = `
          <div style="font-family: sans-serif; padding: 20px; border: 1px solid #eee; border-radius: 5px;">
            <h3 style="color: #0d6efd;">Notifikasi Kiriman Nilai</h3>
            <p>Halo Admin,</p>
            <p>Guru <strong>${nama}</strong> telah mengirimkan nilai untuk:</p>
            <ul>
              <li><strong>Mata Pelajaran:</strong> ${nama_mapel}</li>
              <li><strong>Tahun Ajaran:</strong> ${deskripsiTA}</li>
              <li><strong>Waktu Kirim:</strong> ${new Date().toLocaleString('id-ID')}</li>
            </ul>
            <p>Status saat ini: <strong style="color: #fd7e14;">PENDING</strong> (Menunggu Persetujuan).</p>
            <p>Silakan login ke Aplikasi 1 (Menu Kelola Nilai Guru) untuk meninjau, menyetujui, atau meminta revisi.</p>
          </div>
        `;
        _sendEmailApp2(adminEmail, subjectAdmin, bodyAdmin);
      }

      // C. Email ke GURU (Konfirmasi)
      const subjectGuru = `[Terkirim] Nilai ${nama_mapel} Berhasil Dikirim`;
      const bodyGuru = `
        <div style="font-family: sans-serif; padding: 20px; border: 1px solid #eee; border-radius: 5px;">
          <h3 style="color: #198754;">Nilai Berhasil Dikirim</h3>
          <p>Halo ${nama},</p>
          <p>Data nilai Anda untuk mapel <strong>${nama_mapel}</strong> (${deskripsiTA}) telah berhasil dikirim ke sistem.</p>
          <p>Status saat ini: <strong style="color: #fd7e14;">PENDING</strong>.</p>
          <p>Admin sekolah akan meninjau nilai tersebut. Anda akan mendapatkan notifikasi selanjutnya jika nilai disetujui atau perlu direvisi.</p>
        </div>
      `;
      _sendEmailApp2(email, subjectGuru, bodyGuru);

    } catch (emailError) {
      Logger.log("Gagal mengirim email notifikasi kirim nilai: " + emailError.message);
      // Tidak melempar error agar proses simpan tetap dianggap sukses oleh UI
    }
    // --- AKHIR LOGIKA EMAIL ---

    return { success: true, message: "Status berhasil dikirim dan notifikasi email telah dikirimkan." };

  } catch (e) {
    Logger.log(`Error di kirimStatusNilai: ${e.message}`);
    return { success: false, error: e.toString() };
  }
}

/**
 * ===== FUNGSI DATA (Langkah 4): Refactored =====
 * Membatalkan status kirim di DB sekolah yang spesifik.
 * @param {string} token - Token sesi.
 */
function batalKirimStatusNilai(token, data) {
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    // 1. Dapatkan sesi dan DB sekolah
    const { ss_sekolah } = _getVerifiedSessionData(token, 'guru');
    
    const { id_tahun_ajaran, email_guru, nama_mapel } = data;

    // 2. Cek kunci T.A.
    if (isTahunAjaranLocked(id_tahun_ajaran, ss_sekolah)) {
      return { success: false, error: "Gagal membatalkan. Tahun Ajaran ini telah dikunci." };
    }

    // 3. Buka sheet 'db_status_kirim' dari 'ss_sekolah'
    const STATUS_KIRIM_SHEET = ss_sekolah.getSheetByName('db_status_kirim');
    if (!STATUS_KIRIM_SHEET) throw new Error("'db_status_kirim' tidak ditemukan.");
    
    const keyToFind = `${id_tahun_ajaran}_${email_guru.toLowerCase()}_${nama_mapel}`;
    const range = STATUS_KIRIM_SHEET.getDataRange();
    const values = range.getValues();

    for (let i = values.length - 1; i >= 1; i--) {
      if (values[i][0] === keyToFind) {
        STATUS_KIRIM_SHEET.deleteRow(i + 1);
        return { success: true, message: "Status berhasil dibatalkan." };
      }
    }
    return { success: true, message: "Status tidak ditemukan." };
  } catch (e) {
    Logger.log(`Error di batalKirimStatusNilai: ${e.message}`);
    return { success: false, error: e.toString() };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [OPTIMASI] Dashboard Status
 */
function getDashboardStatus(token, id_sekolah_req, id_tahun_ajaran) {
    try {
        const session = _getVerifiedSessionData(token);
        let ss_sekolah;

        // REUSE: Jika session sekolah sama dengan request, pakai yang sudah terbuka
        if (session.id_sekolah == id_sekolah_req && session.ss_sekolah) {
            ss_sekolah = session.ss_sekolah;
        } else {
            const dbId = _getApp2DatabaseId(id_sekolah_req);
            ss_sekolah = SpreadsheetApp.openById(dbId);
        }
        
        const mapelSheet = ss_sekolah.getSheetByName('db_mapel');
        const statusSheet = getStatusKirimSheet(ss_sekolah);
        
        const sekolahInfo = SEKOLAH_SHEET.getDataRange().getValues().find(r => r[0] == id_sekolah_req);
        const pengumuman = sekolahInfo ? sekolahInfo[8] : "";

        // Ambil Nama Guru dari Global
        const guruMap = {};
        GURU_SHEET.getDataRange().getValues().forEach(r => {
             if(r[3] == id_sekolah_req) guruMap[r[0].toLowerCase()] = r[2];
        });

        // Ambil Mapel
        const mapelData = mapelSheet.getDataRange().getValues().slice(1);
        const targetMapels = mapelData.filter(r => r[2] == id_tahun_ajaran && guruMap[r[0].toLowerCase()]);
        
        // Ambil Status
        const statusData = statusSheet.getDataRange().getValues().slice(1);
        const statusMap = new Map();
        statusData.forEach(r => {
            if(r[1] == id_tahun_ajaran) statusMap.set(`${r[2].toLowerCase()}_${r[3]}`, {status: r[6], alasan: r[7]});
        });

        const result = targetMapels.map(r => {
            const email = r[0].toLowerCase();
            const mapel = r[1];
            const st = statusMap.get(`${email}_${mapel}`);
            return {
                nama: guruMap[email],
                email: r[0],
                mapel: mapel,
                status: st ? st.status : null,
                alasan: st ? st.alasan : null
            };
        });
        
        return { success: true, statusList: result, pengumuman: pengumuman };

    } catch (e) { return { error: e.message }; }
}

/**
 * [INTERNAL HELPER] Logika inti untuk mengambil data cetak.
 */
function _getCetakDataInternal(ss_sekolah, app1_db_id, id_sekolah, email_guru, jenjangPilihan, req) {
  const isLocked = isTahunAjaranLocked(req.id_tahun_ajaran, ss_sekolah);
  const filterKelas = req.filterKelas || 'semua';
  
  // REUSE: Panggil internal helper tanpa buka SS baru
  const nilaiResponse = _getSiswaAndNilaiInternal(
      ss_sekolah, id_sekolah, email_guru, 
      req.nama_mapel, req.id_tahun_ajaran, 0, filterKelas, ''
  );
  
  if (nilaiResponse.error) throw new Error(nilaiResponse.error);
  
  const nilaiSiswa = nilaiResponse.siswaData.map(s => {
    let nilaiFinal = null;
    const nU = (s.nilai_ujian !== '' && s.nilai_ujian != null) ? parseFloat(s.nilai_ujian) : null;
    const nP = (s.nilai_praktek !== '' && s.nilai_praktek != null) ? parseFloat(s.nilai_praktek) : null;
    
    if (nilaiResponse.showUS && nU != null && nilaiResponse.showUP && nP != null) nilaiFinal = (nU + nP) / 2;
    else if (nilaiResponse.showUS && nU != null) nilaiFinal = nU;
    else if (nilaiResponse.showUP && nP != null) nilaiFinal = nP;
    
    return {
      ...s,
      nilai: (nilaiFinal === null) ? '' : Math.round(nilaiFinal),
      nilai_huruf: (nilaiFinal === null) ? '' : terbilang(Math.round(nilaiFinal))
    };
  });

  // Buka App 1 DB (Ini tidak bisa dihindari karena beda file, tapi hanya sekali)
  const ss_app1 = SpreadsheetApp.openById(app1_db_id);
  
  const dataSekolahSheet = ss_app1.getSheetByName('Data_Sekolah');
  const sekolahValues = dataSekolahSheet.getRange("A2:P2").getValues()[0];
  const sekolahInfo = { kepala_sekolah: sekolahValues[14] || 'Belum Diatur', nip_kepsek: sekolahValues[15] || '-' };
  
  const akunGuruSheet = ss_app1.getSheetByName('Akun_Guru');
  const guruData = akunGuruSheet.getDataRange().getValues().slice(1);
  const foundGuru = guruData.find(r => r[0].toLowerCase() === email_guru.toLowerCase());
  const guruInfo = { nama: foundGuru ? foundGuru[1] : 'Guru Tdk Ditemukan', nip: foundGuru ? (foundGuru[2] || '-') : '-' };

  // Optimasi: Ambil pengaturan cetak langsung dari 'sekolahValues' yang sudah kita baca di atas
  // sekolahValues indeks: 16=TanggalCetak, 19=TempatTTD, 20=Mode
  let tanggalCetak = sekolahValues[16];
  if (tanggalCetak instanceof Date) tanggalCetak = Utilities.formatDate(tanggalCetak, Session.getScriptTimeZone(), "yyyy-MM-dd");
  
  const pengaturanFinal = {
    tempat: sekolahValues[19] || '',
    tanggalFormatted: '______'
  };
  
  // Logic Tanggal
  const keyCek = `${req.id_tahun_ajaran}_${email_guru.toLowerCase()}_${req.nama_mapel}`;
  const statusSheet = getStatusKirimSheet(ss_sekolah);
  const statusRow = statusSheet.getDataRange().getValues().find(r => r[0] === keyCek);
  const isSudahKirim = !!statusRow;
  
  let tglRaw = new Date();
  if (isSudahKirim && statusRow[5]) tglRaw = statusRow[5];
  else if (sekolahValues[20] === 'manual' && tanggalCetak) tglRaw = tanggalCetak;
  
  try {
    if (typeof tglRaw === 'string' && tglRaw.includes('-')) {
        const p = tglRaw.split('-');
        tglRaw = new Date(p[0], p[1]-1, p[2]);
    }
    pengaturanFinal.tanggalFormatted = tglRaw.toLocaleDateString('id-ID', { day: 'numeric', month: 'long', year: 'numeric' });
  } catch(e) {}

  return {
    requestID: req.requestID,
    nilai_siswa: nilaiSiswa,
    sekolah: sekolahInfo,
    guru: guruInfo,
    pengaturan: pengaturanFinal,
    deskripsi_ta: req.deskripsi_ta,
    nama_mapel: req.nama_mapel,
    isSudahKirim: isSudahKirim,
    isTahunAjaranLocked: isLocked,
    jenjangPilihan: jenjangPilihan,
    statusApproval: isSudahKirim ? statusRow[6] : null,
    alasanTolak: isSudahKirim ? statusRow[7] : null,
    nama_kelas: (filterKelas === 'semua' || filterKelas === '*') ? 'Semua Kelas' : filterKelas
  };
}

/**
 * [WRAPPER] Mengambil data cetak untuk Client
 */
function getCetakData(token, req) {
  try {
    const session = _getVerifiedSessionData(token, 'guru');
    return _getCetakDataInternal(session.ss_sekolah, session.app1_db_id, session.id_sekolah, session.email, session.jenjangPilihan, req);
  } catch (e) {
    return { error: e.toString() };
  }
}

/**
 * [OPTIMASI] Generate PDF dengan Kolom NISN (Ganti Nomor Ujian).
 */
function generatePdfAsBase64(token, data) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); 
  
  try {
    // 1. Buka Sesi
    const session = _getVerifiedSessionData(token, 'guru');
    const { ss_sekolah, id_sekolah, email, jenjangPilihan, app1_db_id } = session;

    // 2. Ambil Info TA
    const taSheet = ss_sekolah.getSheetByName('db_tahun_ajaran');
    const taRow = taSheet.getDataRange().getValues().find(r => r[0] == data.id_tahun_ajaran);
    const deskripsi_ta = taRow ? taRow[1] : 'N/A';

    // 3. Panggil Internal Helper Data
    const req = { 
        id_sekolah, 
        nama_mapel: data.nama_mapel, 
        id_tahun_ajaran: data.id_tahun_ajaran, 
        email_guru: email, 
        deskripsi_ta, 
        filterKelas: data.filterKelas || 'semua' 
    };
    
    const allData = _getCetakDataInternal(ss_sekolah, app1_db_id, id_sekolah, email, jenjangPilihan, req);
    if (allData.error) throw new Error(allData.error);

    // 4. Ambil Data dari Master Sheet
    const masterSS_App1 = SpreadsheetApp.openById(ID_MASTER_SHEET_APLIKASI_1);
    const sheetSekolah_App1 = masterSS_App1.getSheetByName('Sheet_Sekolah');
    const sekolahRow = sheetSekolah_App1.getDataRange().getValues().slice(1).find(row => row[0] == id_sekolah);
    
    const kopSuratFileId = sekolahRow ? sekolahRow[15] : null; // Kolom P
    const namaSekolah = sekolahRow ? sekolahRow[1] : 'SEKOLAH'; // Kolom B
    
    if (sekolahRow) {
       const tempatDariMaster = sekolahRow[19]; // Kolom T
       if (tempatDariMaster) {
          allData.pengaturan.tempat = tempatDariMaster;
       }
    }
    
    let headerHtml = '';
    if (kopSuratFileId) {
       const kopBase64 = _getImageAsBase64DataUrl(kopSuratFileId);
       if (kopBase64) headerHtml = `<div style="width: 100%; margin-bottom: 10px; border-bottom: 3px solid black;"><img src="${kopBase64}" style="width: 100%; height: auto;"></div>`;
    }
    
    const isKemenag = (jenjangPilihan.includes('M'));
    const labelUjian = isKemenag ? "NILAI UJIAN MADRASAH" : "NILAI UJIAN SEKOLAH"; 
    const labelJabatan = isKemenag ? "Kepala Madrasah" : "Kepala Sekolah";
    
    let rowsHtml = '';
    if (allData.nilai_siswa.length > 0) {
      allData.nilai_siswa.forEach((item, i) => {
         rowsHtml += `<tr>
            <td class="text-center">${i+1}</td>
            <td class="text-center">${item.ruang_ujian}</td>
            <td class="text-center">${item.nisn || '-'}</td>
            <td style="text-align: left; padding-left: 5px;">${item.nama}</td>
            <td class="text-center">${item.nilai}</td>
            <td style="text-align: left; padding-left: 5px;">${item.nilai_huruf}</td>
         </tr>`;
      });
    } else {
       rowsHtml = '<tr><td colspan="6" class="text-center">Tidak ada data.</td></tr>';
    }
    
    const htmlContent = `
      <html>
      <head>
      <style>
        @page { size: A4; margin: 1cm; }
        body { font-family: Arial, Helvetica, sans-serif; font-size: 10pt; margin: 0; width: 100%; }

        table.data-table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        table.data-table th, table.data-table td { border: 1px solid black; padding: 5px; font-size: 10pt; }
        
        /* Header Tabel Abu-abu (#e0e0e0) */
        table.data-table th { 
            text-align: center; 
            font-weight: bold; 
            background-color: #e0e0e0; 
        }
        
        .info-table { width: 100%; border: none; margin-bottom: 20px; font-size: 10pt; }
        .info-table td { padding: 3px; vertical-align: top; border: none; }
        .info-label { white-space: nowrap; }
        .info-val { font-weight: bold; } 

        .footer-table { width: 100%; margin-top: 40px; border: none; font-size: 10pt; }
        .footer-table td { border: none; vertical-align: top; padding: 0; text-align: left; }
        
        .text-center { text-align: center; }
        .bold-underline { font-weight: bold; text-decoration: underline; }
        .bold { font-weight: bold; }
        .uppercase { text-transform: uppercase; }
      </style>
      </head>
      <body>
        ${headerHtml}
        
        <div style="text-align: center; margin-bottom: 25px; margin-top: 10px;">
            <div class="bold-underline uppercase" style="font-size: 12pt; margin-bottom: 5px;">
                ${labelUjian} ${namaSekolah.toUpperCase()} TAHUN ${new Date().getFullYear()}
            </div>
            <div class="bold uppercase" style="font-size: 11pt;">
                TAHUN AJARAN ${deskripsi_ta}
            </div>
        </div>
        
        <table class="info-table">
            <tr>
                <td width="150" class="info-label">Nama Mata Pelajaran</td>
                <td width="10">:</td>
                <td class="info-val">${allData.nama_mapel}</td>
            </tr>
            <tr>
                <td class="info-label">Guru Pemeriksa</td>
                <td>:</td>
                <td class="info-val">${formatNamaGelar(allData.guru.nama)}</td>
            </tr>
            <tr>
                <td class="info-label">Kelas</td>
                <td>:</td>
                <td class="info-val">${allData.nama_kelas}</td>
            </tr>
        </table>
        
        <table class="data-table">
            <thead>
                <tr>
                    <th width="30">No.</th>
                    <th width="60">Ruang<br>Ujian</th>
                    <th width="100">NISN</th>
                    <th>Nama Peserta Ujian</th>
                    <th width="50">Nilai</th>
                    <th>Nilai dengan huruf</th>
                </tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
        </table>
        
        <table class="footer-table">
            <tr>
                <td width="40%">
                    Mengetahui,<br>
                    ${labelJabatan},<br>
                    <br><br><br><br>
                    <div class="bold-underline">${formatNamaGelar(allData.sekolah.kepala_sekolah)}</div>
                    <div>NIP. ${allData.sekolah.nip_kepsek}</div>
                </td>
                <td width="20%"></td>
                <td width="40%">
                    ${allData.pengaturan.tempat}, ${allData.pengaturan.tanggalFormatted}<br>
                    Guru Pengajar,<br>
                    <br><br><br><br>
                    <div class="bold-underline">${formatNamaGelar(allData.guru.nama)}</div>
                    <div>NIP. ${allData.guru.nip}</div>
                </td>
            </tr>
        </table>
      </body>
      </html>
    `;

    const pdfBlob = Utilities.newBlob(htmlContent, MimeType.HTML).getAs(MimeType.PDF);
    const base64Data = Utilities.base64Encode(pdfBlob.getBytes());
    const finalFileName = `Nilai_${data.nama_mapel}_${allData.guru.nama}_${deskripsi_ta.replace('/', '-')}.pdf`;

    return { base64Data: base64Data, fileName: finalFileName };

  } catch (e) {
    Logger.log(`Generate PDF Error: ${e.message}`);
    return { error: e.toString() };
  } finally {
    lock.releaseLock();
  }
}

/**
 * ===== FUNGSI DATA (Langkah 4): Refactored (Hybrid) =====
 * Menyimpan pengaturan cetak ke DB sekolah, tapi membaca data dari DB global.
 * @param {string} token - Token sesi.
 */
function savePengaturanCetak(token, pengaturan) {
  try {
    // 1. Dapatkan sesi dan DB sekolah
    const { ss_sekolah } = _getVerifiedSessionData(token, 'guru');
    
    // 2. Buka sheet 'db_pengaturan_cetak' dari 'ss_sekolah'
    const PENGATURAN_CETAK_SHEET = ss_sekolah.getSheetByName('db_pengaturan_cetak');
    if (!PENGATURAN_CETAK_SHEET) throw new Error("'db_pengaturan_cetak' tidak ditemukan.");
    
    const data = PENGATURAN_CETAK_SHEET.getDataRange().getValues();
    let rowIndex = -1;
    for (let i = 1; i < data.length; i++) {
      if (data[i][0].toLowerCase() === pengaturan.email.toLowerCase()) {
        rowIndex = i + 1;
        break;
      }
    }
    if (rowIndex > -1) {
      PENGATURAN_CETAK_SHEET.getRange(rowIndex, 2).setValue(pengaturan.preferensi);
      PENGATURAN_CETAK_SHEET.getRange(rowIndex, 3).setValue(null); // Kosongkan kolom C (Obsolete)
    } else {
      PENGATURAN_CETAK_SHEET.appendRow([pengaturan.email, pengaturan.preferensi, null]);
    }
    return { success: true };
  } catch (e) {
    Logger.log(`Error di savePengaturanCetak: ${e.message}`);
    return { success: false, error: e.toString() };
  }
}

function getPengaturanCetak(token, email, id_sekolah) {
  try {
    // 1. Dapatkan sesi (hanya untuk verifikasi, kita tidak pakai ss_sekolah)
    _getVerifiedSessionData(token); 

    // 2. Ambil data dari DB GLOBAL (Aplikasi 1)
    const masterSS_App1 = SpreadsheetApp.openById(ID_MASTER_SHEET_APLIKASI_1);
    const sheetSekolah_App1 = masterSS_App1.getSheetByName('Sheet_Sekolah');
    const sekolahInfoRow = sheetSekolah_App1.getDataRange().getValues().slice(1).find(row => row[0] == id_sekolah);

    if (!sekolahInfoRow) {
      throw new Error("Data sekolah tidak ditemukan di Aplikasi 1.");
    }
    
    // Kolom T (index 19) = TempatTTD
    const tempat_sekolah = sekolahInfoRow[19] || ''; 
    
    // Kolom Q (index 16) = TanggalCetak (Manual)
    let tanggal_manual_raw = sekolahInfoRow[16]; 
    let tanggal_manual_formatted = null;

    if (tanggal_manual_raw instanceof Date && !isNaN(tanggal_manual_raw)) {
      tanggal_manual_formatted = Utilities.formatDate(tanggal_manual_raw, Session.getScriptTimeZone(), "yyyy-MM-dd");
    }

    // Kolom U (index 20) = TanggalTtdMode
    const preferensi = sekolahInfoRow[20] || 'otomatis'; // Default ke 'otomatis'

    return {
      tempat: tempat_sekolah,
      tanggal_manual: tanggal_manual_formatted, // Tanggal dari App 1 Kolom Q
      preferensi_tanggal: preferensi // 'manual' atau 'otomatis' dari App 1 Kolom U
    };
  } catch(e) {
    Logger.log(`Error di getPengaturanCetak: ${e.message}`);
    return { error: e.toString() };
  }
}

/**
 * [FUNGSI BARU PENGGANTI getKelasForMapelCetak]
 * Mengambil daftar kelas SPESIFIK yang diajar guru untuk mapel & T.A. tertentu.
 * Jika guru diatur ["*"] (Semua Kelas), fungsi ini akan mencari
 * semua kelas unik yang memiliki siswa di T.A. tersebut.
 * @returns {Array} Array nama kelas spesifik, e.g., ["VI A", "VI B"]
 */
function getKelasSpesifikUntukGuru(token, id_tahun_ajaran, nama_mapel) {
  try {
    // 1. Dapatkan data sesi (termasuk id_sekolah)
    const { ss_sekolah, email, id_sekolah } = _getVerifiedSessionData(token, 'guru');
    
    const mapelSheet = ss_sekolah.getSheetByName('db_mapel');
    if (!mapelSheet) throw new Error("'db_mapel' tidak ditemukan.");
    
    const mapelData = mapelSheet.getDataRange().getValues().slice(1);
    let kelasJsonFilter = '["*"]'; // Default
    let foundMapel = false;
    
    // 2. Cari pengaturan kelas guru dari db_mapel
    for (const row of mapelData) {
      // row[0]=email, row[1]=mapel, row[2]=id_ta, row[4]=kelas_json
      if (row[1] == nama_mapel && 
          row[2] == id_tahun_ajaran && 
          row[0].toLowerCase() === email.toLowerCase()) {
        
        kelasJsonFilter = row[4] || '["*"]'; // Ambil data kelas (Kolom E)
        foundMapel = true;
        break; 
      }
    }

    if (!foundMapel) {
       // Jika mapel tidak ditemukan (seharusnya tidak terjadi), anggap saja "*"
       kelasJsonFilter = '["*"]';
    }

    let kelasArray;
    try {
      kelasArray = JSON.parse(kelasJsonFilter);
    } catch(e) {
      kelasArray = ["*"];
    }

    // 3. Logika Inti: Tentukan daftar kelas spesifik
    if (kelasArray.includes("*")) {
        // KASUS 1: Guru mengajar "Semua Kelas"
        // Kita harus cari tahu apa saja kelas yang *sebenarnya* ada siswanya di T.A. ini
        
        // 3a. Ambil data siswa (db_siswa)
        const masterSiswaData = ss_sekolah.getSheetByName('db_siswa').getDataRange().getValues().slice(1);
        const masterSiswaMap = masterSiswaData.reduce((map, row) => {
          map[row[0]] = { kelas: row[3] || 'N/A' }; // map[no_ujian] = {kelas}
          return map; 
        }, {});

        // 3b. Ambil data enrollment (db_enrollment)
        const enrollmentData = ss_sekolah.getSheetByName('db_enrollment').getDataRange().getValues().slice(1);
        
        // 3c. Cari kelas unik
        const kelasUnikSet = new Set();
        enrollmentData.forEach(row => {
            // Filter by TA and Sekolah
            if (String(row[2]).trim() == String(id_sekolah).trim() && String(row[3]).trim() == String(id_tahun_ajaran).trim()) {
                const no_ujian = row[1];
                const dataSiswa = masterSiswaMap[no_ujian];
                if (dataSiswa && dataSiswa.kelas !== 'N/A') {
                    kelasUnikSet.add(dataSiswa.kelas);
                }
            }
        });
        
        const kelasUnikList = Array.from(kelasUnikSet);
        if (kelasUnikList.length === 0) {
             // Jika tidak ada siswa sama sekali di TA itu, kembalikan array kosong
             return { status: "sukses", data: [] };
        }
        return { status: "sukses", data: kelasUnikList }; // Cth: ["VI.A", "VI.B"]

    } else {
        // KASUS 2: Guru mengajar kelas spesifik
        // Langsung kembalikan daftar kelasnya
        return { status: "sukses", data: kelasArray }; // Cth: ["VI.A", "VI.B"]
    }

  } catch (e) {
    Logger.log(`Error di getKelasSpesifikUntukGuru: ${e.message}`);
    return { status: "gagal", error: e.toString() };
  }
}

// =================================================================
// ===== FUNGSI-FUNGSI BARU UNTUK FITUR KATROL NILAI =================
// =================================================================
// GANTI FUNGSI INI di aplikasi2/Kode.gs.html
/**
 * [MODIFIED] Mengambil pengaturan katrol dari DB sekolah.
 * Sekarang membaca 4 nilai (Ujian Min/Maks, Praktek Min/Maks).
 */
function getPengaturanKatrol(token, email, id_tahun_ajaran) {
  try {
    // 1. Dapatkan DB sekolah
    const { ss_sekolah } = _getVerifiedSessionData(token, 'guru');
    
    // 2. [MODIFIKASI] Buka sheet menggunakan helper baru
    const PENGATURAN_KATROL_SHEET = _getPengaturanKatrolSheet(ss_sekolah);

    const data = PENGATURAN_KATROL_SHEET.getDataRange().getValues();
    
    // Default values
    let pengaturan = {
      min_hasil_ujian: 60,
      max_hasil_ujian: 90,
      min_hasil_praktek: 60,
      max_hasil_praktek: 90
    };

    for (let i = 1; i < data.length; i++) {
      if (data[i][0].toLowerCase() === email.toLowerCase() && data[i][1] == id_tahun_ajaran) {
        pengaturan.min_hasil_ujian = data[i][2] || 60;   // Kolom C
        pengaturan.max_hasil_ujian = data[i][3] || 90;   // Kolom D
        pengaturan.min_hasil_praktek = data[i][4] || 60; // Kolom E
        pengaturan.max_hasil_praktek = data[i][5] || 90; // Kolom F
        break;
      }
    }
    return pengaturan;
  } catch(e) {
    Logger.log(`Error di getPengaturanKatrol: ${e.message}`);
    return { error: e.toString() };
  }
}

// GANTI FUNGSI INI di aplikasi2/Kode.gs.html
/**
 * [MODIFIED] Menyimpan pengaturan katrol ke DB sekolah.
 * Sekarang menyimpan 4 nilai (Ujian Min/Maks, Praktek Min/Maks).
 */
function savePengaturanKatrol(token, pengaturan) {
  try {
    // 1. Dapatkan DB sekolah
    const { ss_sekolah } = _getVerifiedSessionData(token, 'guru');

    // [MODIFIKASI] Ambil 4 nilai dari objek pengaturan
    const { 
      email, id_tahun_ajaran, 
      min_hasil_ujian, max_hasil_ujian, 
      min_hasil_praktek, max_hasil_praktek 
    } = pengaturan;

    // 2. [MODIFIKASI] Buka sheet menggunakan helper baru
    const PENGATURAN_KATROL_SHEET = _getPengaturanKatrolSheet(ss_sekolah);

    const data = PENGATURAN_KATROL_SHEET.getDataRange().getValues();
    let rowIndex = -1;

    for (let i = 1; i < data.length; i++) {
      if (data[i][0].toLowerCase() === email.toLowerCase() && data[i][1] == id_tahun_ajaran) {
        rowIndex = i + 1;
        break;
      }
    }

    // [MODIFIKASI] Simpan 4 nilai ke kolom C, D, E, F
    if (rowIndex > -1) {
      PENGATURAN_KATROL_SHEET.getRange(rowIndex, 3, 1, 4).setValues([[
        min_hasil_ujian, max_hasil_ujian, 
        min_hasil_praktek, max_hasil_praktek
      ]]);
    } else {
      PENGATURAN_KATROL_SHEET.appendRow([
        email, id_tahun_ajaran, 
        min_hasil_ujian, max_hasil_ujian, 
        min_hasil_praktek, max_hasil_praktek
      ]);
    }
    return { success: true };
  } catch (e) {
    Logger.log(`Error di savePengaturanKatrol: ${e.message}`);
    return { success: false, error: e.toString() };
  }
}

// GANTI FUNGSI INI di aplikasi2/Kode.gs.html
/**
 * [MODIFIED v2] Mengambil hasil katrol dari DB sekolah.
 * Sekarang menerapkan pengaturan katrol UJIAN dan PRAKTEK secara terpisah.
 * [MODIFIKASI v3] Mengambil data kelas dan mengurutkan berdasarkan kelas, lalu nama.
 */
function getHasilKatrol(token, email_guru, id_tahun_ajaran, id_sekolah) {
  try {
    // 1. Dapatkan DB sekolah
    const { ss_sekolah } = _getVerifiedSessionData(token);
    
    // 2. [MODIFIKASI] Ambil 4 Pengaturan Katrol
    const pengaturan = getPengaturanKatrol(token, email_guru, id_tahun_ajaran);
    if (pengaturan.error) throw new Error(pengaturan.error);
    
    // Pengaturan Ujian
    const min_hasil_uj = parseFloat(pengaturan.min_hasil_ujian);
    const max_hasil_uj = parseFloat(pengaturan.max_hasil_ujian);
    const rentang_hasil_uj = max_hasil_uj - min_hasil_uj;
    
    // Pengaturan Praktek
    const min_hasil_pr = parseFloat(pengaturan.min_hasil_praktek);
    const max_hasil_pr = parseFloat(pengaturan.max_hasil_praktek);
    const rentang_hasil_pr = max_hasil_pr - min_hasil_pr;

    // 3. Ambil info mapel (termasuk isUS/isUP) (Tidak berubah)
    const mapelDataSheet = ss_sekolah.getSheetByName('db_mapel').getDataRange().getValues().slice(1);
    const mapelInfoList = mapelDataSheet
      .filter(row => row[0].toLowerCase() === email_guru.toLowerCase() && row[2] == id_tahun_ajaran)
      .map(row => ({
          nama: row[1],
          singkatan: row[3] ? String(row[3]).toUpperCase() : String(row[1]).substring(0,5).toUpperCase(),
          isUS: row[5] === true,
          isUP: row[6] === true
      }))
      .sort((a, b) => a.nama.localeCompare(b.nama));

    if (mapelInfoList.length === 0) {
      return { mapelHeader: [], mapelLegenda: {}, siswaData: [], pengaturan: pengaturan };
    }
    
    // 4. mapelHeader (Tidak berubah)
    const mapelHeader = mapelInfoList.map(item => ({
        singkatan: item.singkatan,
        isUS: item.isUS,
        isUP: item.isUP
    }));
    
    const mapelLegenda = mapelInfoList.reduce((acc, item) => {
        acc[item.singkatan] = item.nama;
        return acc;
    }, {});

    // 5. Ambil Siswa (Tidak berubah)
    const enrollmentData = ss_sekolah.getSheetByName('db_enrollment').getDataRange().getValues().slice(1);
    const enrolledSiswaNos = enrollmentData
      .filter(row => String(row[2]).trim() == String(id_sekolah).trim() && String(row[3]).trim() == String(id_tahun_ajaran).trim())
      .map(row => row[1]);

    // --- [MODIFIKASI DI SINI] ---
    // Ambil nama DAN kelas
    const masterSiswaMap = ss_sekolah.getSheetByName('db_siswa').getDataRange().getValues().slice(1)
      .reduce((map, row) => { 
        map[row[0]] = { // row[0] = nomor_ujian
          nama: row[1] || 'Nama Tdk Ditemukan',
          kelas: row[3] || 'N/A' // Kolom D (index 3)
        }; 
        return map; 
      }, {});

    // --- [MODIFIKASI DI SINI] ---
    // Ambil kelas dan ubah urutan
    const siswaList = enrolledSiswaNos.map(no_ujian => {
      const siswaInfo = masterSiswaMap[no_ujian] || { nama: 'Nama Tdk Ditemukan', kelas: 'N/A' };
      return {
        nomor_ujian: no_ujian,
        nama: siswaInfo.nama,
        kelas: siswaInfo.kelas // <-- AMBIL KELAS
      };
    }).sort((a, b) => {
      // URUTAN BARU: Kelas, lalu Nama
      const compareKelasVal = compareKelas(a.kelas, b.kelas); // Gunakan helper compareKelas
      if (compareKelasVal !== 0) {
        return compareKelasVal;
      }
      return a.nama.localeCompare(b.nama);
    });
    // --- [AKHIR MODIFIKASI] ---

    if (siswaList.length === 0) {
      return { mapelHeader: mapelHeader, mapelLegenda: mapelLegenda, siswaData: [], pengaturan: pengaturan };
    }

    // 6. Ambil Nilai Asli Ujian & Praktek (Tidak berubah)
    const NILAI_ASLI_SHEET = getNilaiAsliSheetByTahunAjaran(id_tahun_ajaran, ss_sekolah);
    const nilaiAsliData = NILAI_ASLI_SHEET.getDataRange().getValues().slice(1);
    
    const asliMap = nilaiAsliData.reduce((map, row) => {
      const key = `${row[1]}_${row[2]}`;
      map[key] = { 
        ujian: parseFloat(row[3]),
        praktek: parseFloat(row[4])
      };
      return map;
    }, {});

    // 7. [MODIFIKASI] Proses dan Katrol (tambahkan 'kelas' ke objek row)
    const siswaData = siswaList.map(siswa => {
      // --- [MODIFIKASI DI SINI] ---
      let row = { 
        nama: siswa.nama, 
        nomor_ujian: siswa.nomor_ujian, 
        kelas: siswa.kelas, // <-- TAMBAHKAN KELAS
        nilai_mapel: {} 
      };
      // --- [AKHIR MODIFIKASI] ---
      
      mapelInfoList.forEach(mapelInfo => {
        const key = `${siswa.nomor_ujian}_${mapelInfo.nama}`;
        const nilai_asli_obj = asliMap[key];
        
        let display_nilai_ujian = null;
        let display_nilai_praktek = null;

        if (nilai_asli_obj) {
          // Katrol Nilai Ujian
          if (mapelInfo.isUS && nilai_asli_obj.ujian !== undefined && !isNaN(nilai_asli_obj.ujian)) {
            // Gunakan pengaturan UJIAN
            let nilai_terkatrol_uj = min_hasil_uj + (nilai_asli_obj.ujian / 100) * rentang_hasil_uj;
            display_nilai_ujian = Math.round(nilai_terkatrol_uj);
          }
          // Katrol Nilai Praktek
          if (mapelInfo.isUP && nilai_asli_obj.praktek !== undefined && !isNaN(nilai_asli_obj.praktek)) {
            // Gunakan pengaturan PRAKTEK
            let nilai_terkatrol_pr = min_hasil_pr + (nilai_asli_obj.praktek / 100) * rentang_hasil_pr;
            display_nilai_praktek = Math.round(nilai_terkatrol_pr);
          }
        }
        
        row.nilai_mapel[mapelInfo.singkatan] = {
          ujian: (display_nilai_ujian === null ? '' : display_nilai_ujian),
          praktek: (display_nilai_praktek === null ? '' : display_nilai_praktek)
        };
      });
      return row;
    });

    // 8. Kembalikan data (termasuk objek pengaturan lengkap)
    return { mapelHeader: mapelHeader, mapelLegenda: mapelLegenda, siswaData: siswaData, pengaturan: pengaturan };

  } catch(e) {
    Logger.log(`Error di getHasilKatrol: ${e.message}`);
    return { error: e.toString() };
  }
}

// GANTI FUNGSI INI di aplikasi2/Kode.gs.html
/**
 * [MODIFIED v2] Mengambil nilai katrol UJIAN dan PRAKTEK untuk satu mapel.
 * Fungsi ini sekarang mengembalikan objek { ujian: nilai, praktek: nilai }.
 */
function getNilaiKatrolForMapel(token, email_guru, id_tahun_ajaran, id_sekolah, nama_mapel) {
  try {
    // 1. Dapatkan DB sekolah
    const { ss_sekolah } = _getVerifiedSessionData(token);

    // 2. [MODIFIKASI] Ambil 4 Pengaturan Katrol
    const pengaturan = getPengaturanKatrol(token, email_guru, id_tahun_ajaran);
    if (pengaturan.error) throw new Error(pengaturan.error);
    
    // Pengaturan Ujian
    const min_hasil_uj = parseFloat(pengaturan.min_hasil_ujian);
    const max_hasil_uj = parseFloat(pengaturan.max_hasil_ujian);
    const rentang_hasil_uj = max_hasil_uj - min_hasil_uj;
    
    // Pengaturan Praktek
    const min_hasil_pr = parseFloat(pengaturan.min_hasil_praktek);
    const max_hasil_pr = parseFloat(pengaturan.max_hasil_praktek);
    const rentang_hasil_pr = max_hasil_pr - min_hasil_pr;

    // 3. Ambil Siswa (Tidak berubah)
    const enrollmentData = ss_sekolah.getSheetByName('db_enrollment').getDataRange().getValues().slice(1);
    const enrolledSiswaNos = enrollmentData
      .filter(row => String(row[2]).trim() == String(id_sekolah).trim() && String(row[3]).trim() == String(id_tahun_ajaran).trim())
      .map(row => row[1]);

    if (enrolledSiswaNos.length === 0) {
      return { nilaiKatrolMap: {} }; // Kembalikan map kosong
    }

    // 4. [MODIFIKASI] Ambil Nilai Asli (Ujian DAN Praktek)
    const NILAI_ASLI_SHEET = getNilaiAsliSheetByTahunAjaran(id_tahun_ajaran, ss_sekolah);
    const nilaiAsliData = NILAI_ASLI_SHEET.getDataRange().getValues().slice(1);

    const asliMap = nilaiAsliData
      .filter(row => row[2] == nama_mapel) // Filter by mapel
      .reduce((map, row) => {
        map[row[1]] = {
          ujian: parseFloat(row[3]),   // Kolom D (nilai_asli_ujian)
          praktek: parseFloat(row[4]) // Kolom E (nilai_asli_praktek)
        };
        return map;
      }, {});

    // 5. [MODIFIKASI] Hitung katrol untuk kedua nilai
    const nilaiKatrolMap = {}; // Ini sekarang akan menyimpan objek
    
    enrolledSiswaNos.forEach(no_ujian => {
      const nilai_asli_obj = asliMap[no_ujian];
      let katrol_ujian = null;
      let katrol_praktek = null;

      if (nilai_asli_obj) {
        // Hitung katrol ujian
        if (nilai_asli_obj.ujian !== undefined && !isNaN(nilai_asli_obj.ujian)) {
          let nilai_terkatrol = min_hasil_uj + (nilai_asli_obj.ujian / 100) * rentang_hasil_uj;
          katrol_ujian = Math.round(nilai_terkatrol);
        }
        // Hitung katrol praktek
        if (nilai_asli_obj.praktek !== undefined && !isNaN(nilai_asli_obj.praktek)) {
          let nilai_terkatrol = min_hasil_pr + (nilai_asli_obj.praktek / 100) * rentang_hasil_pr;
          katrol_praktek = Math.round(nilai_terkatrol);
        }
      }
      
      // Simpan objek ke map
      // (Bahkan jika nilai null, kita tetap kirim objeknya agar frontend bisa cek)
      nilaiKatrolMap[no_ujian] = {
        ujian: katrol_ujian,
        praktek: katrol_praktek
      };
    });

    return { nilaiKatrolMap: nilaiKatrolMap }; // Kembalikan map of objects

  } catch(e) {
    Logger.log(`Error di getNilaiKatrolForMapel: ${e.message}`);
    return { error: e.toString() };
  }
}

// =================================================================
// ===== FUNGSI UTILITAS (Terbilang) ===============================
// =================================================================
function terbilang(n) {
    if (n < 0 || n > 100 || isNaN(n) || n === '') return '';
    if (n === 100) return 'Seratus';
    if (n === 0) return 'Nol';
    const satuan = ["", "Satu", "Dua", "Tiga", "Empat", "Lima", "Enam", "Tujuh", "Delapan", "Sembilan", "Sepuluh", "Sebelas"];
    if (n < 12) return satuan[n];
    if (n < 20) return satuan[n - 10] + " Belas";
    const puluhan = Math.floor(n / 10);
    const sisa = n % 10;
    return (satuan[puluhan] + " Puluh") + (sisa === 0 ? '' : " " + satuan[sisa]);
}


// =================================================================
// ===== FUNGSI-FUNGSI SUPERADMIN ==================================
// =================================================================

/**
 * [SUPERADMIN V2.9] Mengambil semua sekolah untuk dropdown. (sama)
 */
function superadmin_getAllSchools(userEmail) {
  // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) {
    return { error: "Akses ditolak." };
  }

  // 2. Ambil Data
  try {
    const sekolahData = SEKOLAH_SHEET.getDataRange().getValues().slice(1);
    const schools = sekolahData.map(row => ({
      id_sekolah: row[0],
      nama_sekolah: row[1]
    })).sort((a, b) => a.nama_sekolah.localeCompare(b.nama_sekolah));

    return { success: true, data: schools };
  } catch (e) {
    return { error: e.toString() };
  }
}


/**
 * [SUPERADMIN V2.11] Mengambil semua data guru, diurutkan per sekolah.
 */
function superadmin_getAllTeachers(userEmail) {
  // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) {
    return { error: "Akses ditolak." };
  }

  // 2. Ambil Data Guru & Sekolah
  try {
    const dataGuru = GURU_SHEET.getDataRange().getValues().slice(1);
    const sekolahData = SEKOLAH_SHEET.getDataRange().getValues().slice(1);
    const sekolahMap = sekolahData.reduce((map, row) => {
      map[row[0]] = row[1]; // id_sekolah -> nama_sekolah
      return map;
    }, {});

    const teachers = dataGuru.map(row => ({
      email: row[0],
      // Jangan kirim password (row[1])
      nama: row[2],
      id_sekolah: row[3],
      nama_sekolah: sekolahMap[row[3]] || 'SEKOLAH TIDAK DIKENAL', // Tambahkan nama sekolah
      role: row[4] || 'guru' // Kolom E
    }));

    // 3. Urutkan berdasarkan Nama Sekolah, lalu Nama Guru
    teachers.sort((a, b) => {
      const compareSekolah = a.nama_sekolah.localeCompare(b.nama_sekolah);
      if (compareSekolah !== 0) {
        return compareSekolah;
      }
      // Jika sekolah sama, urutkan berdasarkan nama guru
      const compareNama = a.nama.localeCompare(b.nama);
       if (compareNama !== 0) {
        return compareNama;
      }
      // Jika nama sama (jarang terjadi), urutkan berdasarkan email
      return a.email.localeCompare(b.email);
    });

    return { success: true, data: teachers };
  } catch (e) {
    return { error: e.toString() };
  }
}

/**
 * [SUPERADMIN V2.11] Menyimpan data guru (Tambah/Edit).
 * @param {string} userEmail - Email superadmin.
 * @param {object} teacherData - Data guru { email, nama, password, id_sekolah, role }.
 * @param {boolean} isEditing - True jika sedang mengedit (email tidak diubah).
 */
function superadmin_saveTeacher(userEmail, teacherData, isEditing) {
  // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) {
    return { error: "Akses ditolak." };
  }

  // 2. Validasi Input Dasar
  if (!teacherData || !teacherData.email || !teacherData.nama || !teacherData.id_sekolah || !teacherData.role) {
    return { error: "Data tidak lengkap (Email, Nama, Sekolah, Role wajib diisi)." };
  }
  // Password wajib diisi saat menambah baru
  if (!isEditing && !teacherData.password) {
     return { error: "Password wajib diisi saat menambah guru baru." };
  }
  // Pastikan role valid
  const validRoles = ['guru', 'superadmin'];
  if (!validRoles.includes(teacherData.role.toLowerCase())) {
     return { error: `Role tidak valid: ${teacherData.role}. Gunakan 'guru' atau 'superadmin'.` };
  }
   // Validasi format email sederhana
   if (teacherData.email.indexOf('@') === -1 || teacherData.email.indexOf('.') === -1) {
     return { error: "Format email tidak valid." };
   }

  // 3. Proses Simpan/Update
  const lock = LockService.getScriptLock();
  lock.waitLock(15000); // Tunggu hingga 15 detik
  try {
    const dataGuru = GURU_SHEET.getDataRange().getValues();
    const emailLower = teacherData.email.toLowerCase();
    let rowIndex = -1;

    // Cari baris berdasarkan email
    for (let i = 1; i < dataGuru.length; i++) {
      if (dataGuru[i][0].toLowerCase() === emailLower) {
        rowIndex = i + 1; // Baris di sheet (mulai dari 1)
        break;
      }
    }

    if (isEditing) {
      if (rowIndex === -1) {
        // Seharusnya tidak terjadi jika dipanggil dari tombol edit, tapi tambahkan pengecekan
        return { error: `Guru dengan email ${teacherData.email} tidak ditemukan untuk diedit.` };
      }
      // Update data di baris yang ditemukan
      // Kolom C: Nama, D: id_sekolah, E: Role
      GURU_SHEET.getRange(rowIndex, 3).setValue(teacherData.nama);
      GURU_SHEET.getRange(rowIndex, 4).setValue(teacherData.id_sekolah);
      GURU_SHEET.getRange(rowIndex, 5).setValue(teacherData.role);
      if (teacherData.password) { // Update password hanya jika diisi
        GURU_SHEET.getRange(rowIndex, 2).setValue(teacherData.password);
      }
       return { success: true, message: `Data guru ${teacherData.nama} berhasil diperbarui.` };
    } else {
      // Menambah guru baru
      if (rowIndex !== -1) {
        return { error: `Email ${teacherData.email} sudah terdaftar.` };
      }
      // Tambah baris baru
      GURU_SHEET.appendRow([
        teacherData.email,        // Kolom A
        teacherData.password,     // Kolom B
        teacherData.nama,         // Kolom C
        teacherData.id_sekolah,   // Kolom D
        teacherData.role          // Kolom E
      ]);
       return { success: true, message: `Guru ${teacherData.nama} berhasil ditambahkan.` };
    }

  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN V2.11] Menghapus data guru.
 * @param {string} userEmail - Email superadmin.
 * @param {string} teacherEmailToDelete - Email guru yang akan dihapus.
 */
function superadmin_deleteTeacher(userEmail, teacherEmailToDelete) {
 // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) {
    return { error: "Akses ditolak." };
  }
   if (!teacherEmailToDelete) {
     return { error: "Email guru yang akan dihapus tidak valid." };
   }
   // [PENTING] Jangan biarkan superadmin menghapus dirinya sendiri
   if (userEmail.toLowerCase() === teacherEmailToDelete.toLowerCase()) {
      return { error: "Tidak dapat menghapus akun Anda sendiri." };
   }

  // 2. Proses Hapus
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const range = GURU_SHEET.getDataRange();
    const values = range.getValues();
    const emailLowerToDelete = teacherEmailToDelete.toLowerCase();
    let rowDeleted = false;

    // Cari dari bawah agar index tidak bergeser saat menghapus
    for (let i = values.length - 1; i >= 1; i--) {
      if (values[i][0].toLowerCase() === emailLowerToDelete) {
        GURU_SHEET.deleteRow(i + 1);
        rowDeleted = true;
        break; // Hapus hanya satu baris jika ditemukan
      }
    }

    if (rowDeleted) {
       // [OPSIONAL] Hapus token login guru yang dihapus dari PropertiesService
       const properties = PropertiesService.getScriptProperties();
       const tokenKey = 'token_' + emailLowerToDelete;
       const token = properties.getProperty(tokenKey);
       if (token) {
           const authKey = 'auth_' + token;
           properties.deleteProperty(tokenKey);
           properties.deleteProperty(authKey);
       }
       return { success: true, message: `Guru dengan email ${teacherEmailToDelete} berhasil dihapus.` };
    } else {
       return { error: `Guru dengan email ${teacherEmailToDelete} tidak ditemukan.` };
    }

  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan saat menghapus: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN BARU] Memulai sesi sebagai guru lain.
 * @param {string} adminEmail - Email superadmin yang melakukan aksi.
 * @param {string} teacherEmailToImpersonate - Email guru yang akan di-impersonate.
 * @returns {object} Objek data user guru (sama seperti userLogin) atau { error: "..." }.
 */
function superadmin_impersonateTeacher(adminEmail, teacherEmailToImpersonate) {
  // 1. Verifikasi Keamanan Superadmin
  if (!isSuperadmin(adminEmail)) {
    return { error: "Akses ditolak." };
  }

  const properties = PropertiesService.getScriptProperties();
  const dataGuru = GURU_SHEET.getDataRange().getValues();
  const teacherEmailLower = teacherEmailToImpersonate.toLowerCase();

  // 2. Cari data guru yang akan di-impersonate
  for (let i = 1; i < dataGuru.length; i++) {
    const row = dataGuru[i];
    const sheetEmailLower = row[0].toLowerCase();

    if (sheetEmailLower === teacherEmailLower) {
      const email = row[0];
      const nama = row[2];
      const id_sekolah = row[3];
      const role = row[4] || 'guru';

      // 3. Dapatkan/Buat Token (logika disalin dari userLogin)
      const tokenKey = 'token_' + email.toLowerCase();
      let token = properties.getProperty(tokenKey);

      if (!token) {
        // Jika token tidak ada, buat baru
        token = 'tok-' + Utilities.getUuid();
        const authKey = 'auth_' + token;
        const now = new Date().getTime();
        const authData = JSON.stringify({
          email: email.toLowerCase(),
          timestamp: now 
        });

        properties.setProperties({
          [tokenKey]: token,
          [authKey]: authData
        });
      } else {
         // [PENTING] Jika token sudah ada, perbarui timestamp-nya
         // agar tidak kedaluwarsa saat admin login.
         const authKey = 'auth_' + token;
         const authDataString = properties.getProperty(authKey);
         if (authDataString) {
           try {
             let authData = JSON.parse(authDataString);
             authData.timestamp = new Date().getTime(); // Perbarui timestamp
             properties.setProperty(authKey, JSON.stringify(authData));
           } catch(e) {
             // Data korup, abaikan saja, verifyToken akan gagal
             Logger.log("Gagal update timestamp impersonate: " + e);
           }
         }
      }

      // 4. Kembalikan data user guru
      return { 
        success: true, 
        user: {
          email: email,
          nama: nama,
          id_sekolah: role === 'superadmin' ? null : id_sekolah,
          token: token,
          role: role
        } 
      };
    }
  }
  
  return { error: "Guru dengan email " + teacherEmailToImpersonate + " tidak ditemukan." };
}

/**
 * [SUPERADMIN] Mengelola Tahun Ajaran (sama seperti sebelumnya)
 */
function superadmin_manageTahunAjaran(userEmail, id_tahun_ajaran, lockStatus) {
  // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) {
    return { error: "Akses ditolak. Anda bukan superadmin." };
  }

  // 2. Proses Aksi
  try {
    const taData = TAHUN_AJARAN_SHEET.getDataRange().getValues();
    for (let i = 1; i < taData.length; i++) {
      if (taData[i][0] == id_tahun_ajaran) {
        // Kolom C (index 2) adalah status_kunci
        TAHUN_AJARAN_SHEET.getRange(i + 1, 3).setValue(lockStatus);
        return { success: true, message: `Tahun Ajaran ${taData[i][1]} berhasil di-${lockStatus ? 'Kunci' : 'Buka'}.` };
      }
    }
    return { error: "Tahun Ajaran tidak ditemukan." };
  } catch (e) {
    return { error: e.toString() };
  }
}

/**
 * [MODIFIKASI] Mengambil data sekolah detail, termasuk template rekap (H) dan pengumuman (I).
 */
function superadmin_getAllSchoolsDetailed(userEmail) {
  if (!isSuperadmin(userEmail)) {
    return { error: "Akses ditolak." };
  }
  try {
    const sekolahData = SEKOLAH_SHEET.getDataRange().getValues().slice(1);
    const schools = sekolahData.map(row => ({
      id_sekolah: row[0],
      nama_sekolah: row[1],
      tempat_ttd: row[2],
      kepala_sekolah: row[3],
      nip_kepsek: row[4],
      template_id: row[5],
      tanggal_sistem: row[6] instanceof Date ? Utilities.formatDate(row[6], Session.getScriptTimeZone(), "yyyy-MM-dd") : null,
      template_rekap: row[7] || '', // <-- TAMBAHKAN (Kolom H)
      pengumuman: row[8] || ''      // <-- TAMBAHKAN (Kolom I)
    })).sort((a, b) => a.nama_sekolah.localeCompare(b.nama_sekolah));

    return { success: true, data: schools };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  }
}

/**
 * [MODIFIKASI] Menyimpan data sekolah, termasuk template rekap (H) dan pengumuman (I).
 */
function superadmin_saveSchool(userEmail, schoolData, isEditing) {
  if (!isSuperadmin(userEmail)) { return { error: "Akses ditolak." }; }

  if (!schoolData || !schoolData.id_sekolah || !schoolData.nama_sekolah || !schoolData.tempat_ttd || !schoolData.kepala_sekolah || !schoolData.template_id) {
    return { error: "Data tidak lengkap (ID, Nama, Tempat TTD, Kepala Sekolah, Template ID wajib diisi)." };
  }

  let formattedDate = null;
  if (schoolData.tanggal_sistem) {
    try {
      const parts = schoolData.tanggal_sistem.split('-');
      if (parts.length === 3) {
         formattedDate = new Date(parseInt(parts[0], 10), parseInt(parts[1], 10) - 1, parseInt(parts[2], 10));
         if (isNaN(formattedDate)) formattedDate = null;
      }
    } catch (e) {
        Logger.log("Error parsing date: "+ e);
    }
  }

  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const dataSekolah = SEKOLAH_SHEET.getDataRange().getValues();
    const idLower = schoolData.id_sekolah.toLowerCase();
    let rowIndex = -1;

    for (let i = 1; i < dataSekolah.length; i++) {
      if (String(dataSekolah[i][0]).toLowerCase() === idLower) {
        rowIndex = i + 1;
        break;
      }
    }

    // ==== MODIFIKASI: Data sekarang ada 9 kolom (A-I) ====
    const rowData = [
        schoolData.id_sekolah,
        schoolData.nama_sekolah,
        schoolData.tempat_ttd,
        schoolData.kepala_sekolah,
        schoolData.nip_kepsek || '',
        schoolData.template_id,
        formattedDate,
        schoolData.template_rekap || '', // <-- TAMBAHKAN (Kolom H)
        schoolData.pengumuman || ''      // <-- TAMBAHKAN (Kolom I)
    ];

    if (isEditing) {
      if (rowIndex === -1) {
        return { error: `Sekolah dengan ID ${schoolData.id_sekolah} tidak ditemukan.` };
      }
      // ==== MODIFIKASI: Simpan 9 kolom ====
      SEKOLAH_SHEET.getRange(rowIndex, 1, 1, 9).setValues([rowData]);
      return { success: true, message: `Data sekolah ${schoolData.nama_sekolah} berhasil diperbarui.` };
    } else {
      if (rowIndex !== -1) {
        return { error: `ID Sekolah ${schoolData.id_sekolah} sudah digunakan.` };
      }
      // ==== MODIFIKASI: Tambah 9 kolom ====
      SEKOLAH_SHEET.appendRow(rowData);
      return { success: true, message: `Sekolah ${schoolData.nama_sekolah} berhasil ditambahkan.` };
    }

  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN V2.12] Menghapus data sekolah.
 * @param {string} userEmail - Email superadmin.
 * @param {string} schoolIdToDelete - ID sekolah yang akan dihapus.
 */
function superadmin_deleteSchool(userEmail, schoolIdToDelete) {
 // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) { return { error: "Akses ditolak." }; }
  if (!schoolIdToDelete) { return { error: "ID Sekolah tidak valid." }; }

  // 2. Proses Hapus
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const range = SEKOLAH_SHEET.getDataRange();
    const values = range.getValues();
    const idLowerToDelete = String(schoolIdToDelete).toLowerCase(); // Pastikan string dan lowercase
    let rowDeleted = false;
    let schoolName = '';

    // Cari dari bawah
    for (let i = values.length - 1; i >= 1; i--) {
      if (String(values[i][0]).toLowerCase() === idLowerToDelete) {
        schoolName = values[i][1]; // Simpan nama sekolah untuk pesan sukses
        SEKOLAH_SHEET.deleteRow(i + 1);
        rowDeleted = true;
        break;
      }
    }

    if (rowDeleted) {
       // TODO: Tambahkan logika untuk mengecek apakah ada guru/siswa yang masih terdaftar di sekolah ini?
       // Jika ada, mungkin sebaiknya beri peringatan atau cegah penghapusan.
       return { success: true, message: `Sekolah ${schoolName} (${schoolIdToDelete}) berhasil dihapus.` };
    } else {
       return { error: `Sekolah dengan ID ${schoolIdToDelete} tidak ditemukan.` };
    }

  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan saat menghapus: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN V3.1] Mengambil semua data siswa dari db_siswa.
 * [MODIFIKASI] Menghapus sort by name agar urutan sama persis dengan sheet.
 */
function superadmin_getAllSiswa(userEmail) {
  // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) {
    return { error: "Akses ditolak." };
  }

  // 2. Ambil Data
  try {
    const siswaData = SISWA_SHEET.getDataRange().getValues().slice(1);
    
    // MODIFIKASI: .sort((a, b) => a.nama.localeCompare(b.nama)) telah dihapus
    const siswa = siswaData.map(row => ({
      nomor_ujian: row[0], // Kolom A
      nama: row[1]         // Kolom B
    })); 
    
    return { success: true, data: siswa };
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  }
}

/**
 * [SUPERADMIN V3.1 - MODIFIKASI] Menyimpan data siswa (Tambah/Edit).
 * @param {string} userEmail - Email superadmin.
 * @param {object} siswaData - Data siswa { nomor_ujian, nama }.
 * @param {boolean} isEditing - True jika sedang mengedit.
 * @param {string} [originalNomorUjian] - Nomor ujian asli *sebelum* diedit. Wajib diisi saat isEditing=true.
 */
function superadmin_saveSiswa(userEmail, siswaData, isEditing, originalNomorUjian) {
  // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) { return { error: "Akses ditolak." }; }

  // 2. Validasi Input Dasar
  if (!siswaData || !siswaData.nomor_ujian || !siswaData.nama) {
    return { error: "Data tidak lengkap (Nomor Ujian dan Nama wajib diisi)." };
  }
  
  const newNoUjianString = String(siswaData.nomor_ujian).trim();
  const namaSiswa = String(siswaData.nama).trim();

  if (newNoUjianString.length === 0 || namaSiswa.length === 0) {
     return { error: "Nomor Ujian dan Nama tidak boleh kosong." };
  }

  // 3. Proses Simpan/Update
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const dataSiswa = SISWA_SHEET.getDataRange().getValues();
    let rowIndexToUpdate = -1;
    let newIdExists = false;
    let originalNoUjianString = isEditing ? String(originalNomorUjian) : null;

    // [MODIFIKASI] Loop untuk mencari data
    for (let i = 1; i < dataSiswa.length; i++) {
      const currentNoUjian = String(dataSiswa[i][0]);
      
      // Cari baris yang akan diupdate berdasarkan ID ASLI
      if (isEditing && currentNoUjian == originalNoUjianString) {
        rowIndexToUpdate = i + 1; // Ditemukan baris yang akan diupdate
      }
      
      // Cek apakah ID BARU sudah ada di sheet
      if (currentNoUjian == newNoUjianString) {
        newIdExists = true; // Ditemukan ID baru sudah ada
      }
    }

    if (isEditing) {
      if (rowIndexToUpdate === -1) {
        return { error: `Siswa dengan Nomor Ujian asli "${originalNoUjianString}" tidak ditemukan.` };
      }
      
      // Cek jika ID baru sudah ada DI BARIS LAIN
      if (newNoUjianString !== originalNoUjianString && newIdExists) {
        return { error: `Gagal perbarui. Nomor Ujian baru "${newNoUjianString}" sudah digunakan oleh siswa lain.` };
      }
      
      // Update data di baris yang ditemukan
      // Kolom A: Nomor Ujian (BARU), Kolom B: Nama
      SISWA_SHEET.getRange(rowIndexToUpdate, 1).setValue("'" + newNoUjianString);
      SISWA_SHEET.getRange(rowIndexToUpdate, 2).setValue(namaSiswa);
      return { success: true, message: `Data siswa ${namaSiswa} berhasil diperbarui.` };

    } else {
      // Menambah siswa baru
      if (newIdExists) {
        return { error: `Nomor Ujian ${newNoUjianString} sudah terdaftar.` };
      }
      // Tambah baris baru
      SISWA_SHEET.appendRow([
        "'" + newNoUjianString, // Kolom A (beri tanda ' agar jadi teks)
        namaSiswa          // Kolom B
      ]);
      return { success: true, message: `Siswa ${namaSiswa} berhasil ditambahkan.` };
    }

  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN V3.1] Menghapus data siswa.
 * @param {string} userEmail - Email superadmin.
 * @param {string} nomorUjianToDelete - Nomor Ujian siswa yang akan dihapus.
 */
function superadmin_deleteSiswa(userEmail, nomorUjianToDelete) {
 // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) { return { error: "Akses ditolak." }; }
  if (!nomorUjianToDelete) { return { error: "Nomor Ujian tidak valid." }; }

  // 2. Proses Hapus
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const range = SISWA_SHEET.getDataRange();
    const values = range.getValues();
    const noUjianToDeleteString = String(nomorUjianToDelete);
    let rowDeleted = false;
    let siswaName = '';

    // Cari dari bawah
    for (let i = values.length - 1; i >= 1; i--) {
      if (String(values[i][0]) === noUjianToDeleteString) {
        siswaName = values[i][1]; // Simpan nama
        SISWA_SHEET.deleteRow(i + 1);
        rowDeleted = true;
        break;
      }
    }

    if (rowDeleted) {
       // TODO: Hapus juga dari db_enrollment? (Opsional, mungkin berbahaya jika sudah ada nilai)
       return { success: true, message: `Siswa ${siswaName} (${nomorUjianToDelete}) berhasil dihapus.` };
    } else {
       return { error: `Siswa dengan Nomor Ujian ${nomorUjianToDelete} tidak ditemukan.` };
    }

  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan saat menghapus: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN V3.2] Mengambil data enrollment (penempatan) berdasarkan filter.
 * Menggabungkan dengan db_siswa untuk mendapatkan nama.
 */
function superadmin_getEnrollments(userEmail, id_tahun_ajaran, id_sekolah) {
  // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) { return { error: "Akses ditolak." }; }
  if (!id_tahun_ajaran || !id_sekolah) { return { error: "Filter Tahun Ajaran dan Sekolah wajib diisi." }; }

  try {
    // 2. Buat Peta Nama Siswa (Nomor Ujian -> Nama)
    const siswaData = SISWA_SHEET.getDataRange().getValues().slice(1);
    const siswaMap = siswaData.reduce((map, row) => {
      map[String(row[0])] = row[1]; // { "no_ujian": "nama_siswa" }
      return map;
    }, {});

    // 3. Ambil dan Filter Data Enrollment
    const enrollmentData = ENROLLMENT_SHEET.getDataRange().getValues().slice(1);
    const enrollments = [];

    enrollmentData.forEach(row => {
      const rowTA = String(row[3]);
      const rowSekolah = String(row[2]);
      const noUjian = String(row[1]);

      // Filter berdasarkan TA dan Sekolah
      if (rowTA === id_tahun_ajaran && rowSekolah === id_sekolah) {
        enrollments.push({
          id_enrollment: row[0], // Kolom A
          nomor_ujian: noUjian,
          nama_siswa: siswaMap[noUjian] || 'Siswa Tidak Ditemukan', // Ambil nama dari Peta
          id_sekolah: rowSekolah,
          id_tahun_ajaran: rowTA,
          ruang_ujian: row[4] || '' // Kolom E
        });
      }
    });
    
    // Urutkan berdasarkan nama siswa
    enrollments.sort((a, b) => a.nama_siswa.localeCompare(b.nama_siswa));
    return { success: true, data: enrollments };
    
  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan: ${e.toString()}` };
  }
}

/**
 * [SUPERADMIN V3.3 - BATCH] Menyimpan beberapa penempatan siswa sekaligus.
 * Menggantikan superadmin_saveEnrollment.
 * @param {string} userEmail - Email superadmin.
 * @param {Array<object>} studentsToEnroll - Array dari { nomor_ujian, ruang_ujian }.
 * @param {string} id_tahun_ajaran - ID TA target.
 * @param {string} id_sekolah - ID Sekolah target.
 */
function superadmin_saveBatchEnrollment(userEmail, studentsToEnroll, id_tahun_ajaran, id_sekolah) {
  // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) { 
    return { error: "Akses ditolak." }; 
  }
  
  if (!studentsToEnroll || studentsToEnroll.length === 0) {
    return { error: "Tidak ada siswa yang dipilih." };
  }
  if (!id_tahun_ajaran || !id_sekolah) {
    return { error: "Tahun Ajaran atau Sekolah tidak valid." };
  }
  
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); // Lock 30 detik untuk batch operation
  
  try {
    // 2. Cache data master
    const siswaData = SISWA_SHEET.getDataRange().getValues();
    const masterSiswaSet = new Set();
    for (let i = 1; i < siswaData.length; i++) {
      masterSiswaSet.add(String(siswaData[i][0]));
    }

    const enrollmentData = ENROLLMENT_SHEET.getDataRange().getValues();
    const existingEnrollmentSet = new Set();
    // Buat Set data yang sudah ada di TA dan Sekolah ini
    for (let i = 1; i < enrollmentData.length; i++) {
      if (String(enrollmentData[i][2]) === id_sekolah && String(enrollmentData[i][3]) === id_tahun_ajaran) {
        existingEnrollmentSet.add(String(enrollmentData[i][1])); // Add no_ujian
      }
    }

    // 3. Proses batch
    let newRows = [];
    let successCount = 0;
    let failedList = [];

    studentsToEnroll.forEach(student => {
      const noUjianString = String(student.nomor_ujian).trim();
      
      if (!masterSiswaSet.has(noUjianString)) {
        failedList.push(`${noUjianString} (Tidak ada di master)`);
      } else if (existingEnrollmentSet.has(noUjianString)) {
        failedList.push(`${noUjianString} (Sudah terdaftar)`);
      } else {
        // Siswa valid, siapkan untuk ditambah
        const newId = `enroll-${new Date().getTime()}-${Math.random().toString(36).substring(2, 7)}`;
        newRows.push([
          newId,
          "'" + noUjianString,
          id_sekolah,
          id_tahun_ajaran,
          student.ruang_ujian || '' // Kolom E
        ]);
        successCount++;
        // Tambahkan ke set agar tidak diduplikasi dari request yang sama
        existingEnrollmentSet.add(noUjianString); 
      }
    });

    // 4. Simpan ke sheet (jika ada data baru)
    if (newRows.length > 0) {
      ENROLLMENT_SHEET.getRange(ENROLLMENT_SHEET.getLastRow() + 1, 1, newRows.length, 5).setValues(newRows);
    }
    
    // 5. Buat pesan respon
    let message = `Sukses: ${successCount} siswa berhasil ditempatkan.`;
    if (failedList.length > 0) {
      message += ` Gagal: ${failedList.length} siswa (${failedList.join(', ')}).`;
    }
    
    return { success: true, message: message };

  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN V3.2] Menghapus data penempatan siswa (enrollment).
 */
function superadmin_deleteEnrollment(userEmail, id_enrollment) {
  if (!isSuperadmin(userEmail)) { return { error: "Akses ditolak." }; }
  if (!id_enrollment) { return { error: "ID Enrollment tidak valid." }; }

  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const range = ENROLLMENT_SHEET.getDataRange();
    const values = range.getValues();
    let rowDeleted = false;
    let deletedInfo = '';

    for (let i = values.length - 1; i >= 1; i--) {
      if (String(values[i][0]) === id_enrollment) {
        deletedInfo = `Siswa ${values[i][1]} dari TA ${values[i][3]}`;
        ENROLLMENT_SHEET.deleteRow(i + 1);
        rowDeleted = true;
        break;
      }
    }

    if (rowDeleted) {
       return { success: true, message: `Penempatan siswa (${deletedInfo}) berhasil dihapus.` };
    } else {
       return { error: `Data penempatan dengan ID ${id_enrollment} tidak ditemukan.` };
    }

  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan saat menghapus: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN V3.2] Mengupdate Ruang Ujian.
 */
function superadmin_updateRuangUjian(userEmail, id_enrollment, newRuangUjian) {
  if (!isSuperadmin(userEmail)) { return { error: "Akses ditolak." }; }
  if (!id_enrollment) { return { error: "ID Enrollment tidak valid." }; }

  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const data = ENROLLMENT_SHEET.getDataRange().getValues();
    let rowIndex = -1;
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]) === id_enrollment) {
        rowIndex = i + 1;
        break;
      }
    }

    if (rowIndex > -1) {
      ENROLLMENT_SHEET.getRange(rowIndex, 5).setValue(newRuangUjian || ''); // Kolom E
      return { success: true };
    } else {
      return { error: "Data penempatan tidak ditemukan." };
    }
  } catch (e) {
    Logger.log(e);
    return { error: e.toString() };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN V3.4] Mengambil data mapel berdasarkan filter sekolah dan TA.
 */
function superadmin_getAllMapel(userEmail, id_sekolah, id_tahun_ajaran) {
  // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) { return { error: "Akses ditolak." }; }
  if (!id_tahun_ajaran || !id_sekolah) { return { error: "Filter Tahun Ajaran dan Sekolah wajib diisi." }; }

  try {
    // 2. Cache data master
    const guruData = GURU_SHEET.getDataRange().getValues().slice(1);
    const sekolahData = SEKOLAH_SHEET.getDataRange().getValues().slice(1);
    const taData = TAHUN_AJARAN_SHEET.getDataRange().getValues().slice(1);
    
    // 3. Buat Peta Guru di Sekolah ini { "email@lowcase": "Nama Guru" }
    const guruMap = guruData
      .filter(row => row[3] == id_sekolah) // Filter by school
      .reduce((map, row) => {
        map[row[0].toLowerCase()] = row[2]; // email_lower -> nama_guru
        return map;
      }, {});
      
    const emailsInSchool = Object.keys(guruMap);
    if (emailsInSchool.length === 0) {
      return { success: true, data: [] }; // Tidak ada guru, berarti tidak ada mapel
    }

    // 4. Ambil Info Sekolah & TA
    const sekolahInfo = sekolahData.find(row => row[0] == id_sekolah);
    const taInfo = taData.find(row => row[0] == id_tahun_ajaran);
    const namaSekolah = sekolahInfo ? sekolahInfo[1] : 'Sekolah Tdk Ditemukan';
    const deskripsiTA = taInfo ? taInfo[1] : 'TA Tdk Ditemukan';
      
    // 5. Ambil dan Filter Data Mapel
    const mapelData = MAPEL_SHEET.getDataRange().getValues().slice(1);
    const mapelList = [];

    mapelData.forEach(row => {
      const emailGuruLower = row[0].toLowerCase();
      const idTA = String(row[2]);

      // Filter: email guru ada di sekolah INI DAN TA-nya cocok
      if (idTA === id_tahun_ajaran && guruMap[emailGuruLower]) {
        mapelList.push({
          email_guru: row[0],
          nama_guru: guruMap[emailGuruLower],
          id_sekolah: id_sekolah,
          nama_sekolah: namaSekolah,
          id_tahun_ajaran: idTA,
          deskripsi_ta: deskripsiTA,
          mapel: row[1],
          singkatan: row[3] || '' // Kolom D
        });
      }
    });
    
    // 6. Urutkan berdasarkan nama guru, lalu mapel
    mapelList.sort((a, b) => {
      const compareGuru = a.nama_guru.localeCompare(b.nama_guru);
      if (compareGuru !== 0) return compareGuru;
      return a.mapel.localeCompare(b.mapel);
    });
    
    return { success: true, data: mapelList };
    
  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan: ${e.toString()}` };
  }
}

/**
 * [SUPERADMIN V3.4] Menyimpan data mapel (Tambah/Edit).
 * @param {string} userEmail - Email superadmin.
 * @param {object} mapelData - Data mapel baru { email_guru, id_tahun_ajaran, mapel, singkatan }.
 * @param {boolean} isEditing - True jika sedang mengedit.
 * @param {object} [editKey] - Kunci asli { email_guru, mapel, id_tahun_ajaran }.
 */
function superadmin_saveMapel(userEmail, mapelData, isEditing, editKey) {
  // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) { return { error: "Akses ditolak." }; }

  // 2. Validasi Input
  if (!mapelData || !mapelData.email_guru || !mapelData.id_tahun_ajaran || !mapelData.mapel) {
    return { error: "Data tidak lengkap (Guru, TA, dan Nama Mapel wajib diisi)." };
  }
  
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const dataMapel = MAPEL_SHEET.getDataRange().getValues();
    let rowIndexToUpdate = -1;
    let newKeyExists = false;

    // Kunci komposit (Email + Mapel + TA)
    const newKeyString = `${mapelData.email_guru.toLowerCase()}_${mapelData.mapel.toLowerCase()}_${mapelData.id_tahun_ajaran}`;
    const oldKeyString = isEditing ? `${editKey.email_guru.toLowerCase()}_${editKey.mapel.toLowerCase()}_${editKey.id_tahun_ajaran}` : null;

    for (let i = 1; i < dataMapel.length; i++) {
      const row = dataMapel[i];
      const currentRowKey = `${row[0].toLowerCase()}_${row[1].toLowerCase()}_${row[2]}`;
      
      if (isEditing && currentRowKey === oldKeyString) {
        rowIndexToUpdate = i + 1; // Ditemukan baris yang akan diupdate
      }
      
      if (currentRowKey === newKeyString) {
        newKeyExists = true; // Ditemukan kunci baru sudah ada
      }
    }

    // Data yang akan disimpan (A, B, C, D)
    const rowData = [
      mapelData.email_guru,
      mapelData.mapel,
      mapelData.id_tahun_ajaran,
      mapelData.singkatan || ''
    ];

    if (isEditing) {
      if (rowIndexToUpdate === -1) {
        return { error: `Mapel asli tidak ditemukan untuk diedit.` };
      }
      
      // Cek jika kunci baru sudah ada DI BARIS LAIN
      if (newKeyString !== oldKeyString && newKeyExists) {
        return { error: `Gagal perbarui. Kombinasi Guru, Mapel, dan TA tersebut sudah ada.` };
      }
      
      // Update data di baris yang ditemukan (Range A:D)
      MAPEL_SHEET.getRange(rowIndexToUpdate, 1, 1, 4).setValues([rowData]);
      return { success: true, message: `Data mapel ${mapelData.mapel} berhasil diperbarui.` };

    } else {
      // Menambah mapel baru
      if (newKeyExists) {
        return { error: `Kombinasi Guru, Mapel, dan TA tersebut sudah terdaftar.` };
      }
      // Tambah baris baru
      MAPEL_SHEET.appendRow(rowData);
      return { success: true, message: `Mapel ${mapelData.mapel} berhasil ditambahkan.` };
    }

  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [SUPERADMIN V3.4] Menghapus data mapel.
 * @param {string} userEmail - Email superadmin.
 * @param {object} key - Kunci komposit { email_guru, mapel, id_tahun_ajaran }.
 */
function superadmin_deleteMapel(userEmail, key) {
 // 1. Verifikasi Keamanan
  if (!isSuperadmin(userEmail)) { return { error: "Akses ditolak." }; }
  if (!key || !key.email_guru || !key.mapel || !key.id_tahun_ajaran) {
    return { error: "Kunci data mapel tidak valid." };
  }

  // 2. Proses Hapus
  const lock = LockService.getScriptLock();
  lock.waitLock(15000);
  try {
    const range = MAPEL_SHEET.getDataRange();
    const values = range.getValues();
    
    const emailLower = key.email_guru.toLowerCase();
    const mapelLower = key.mapel.toLowerCase();
    const taID = key.id_tahun_ajaran;
    
    let rowDeleted = false;

    // Cari dari bawah
    for (let i = values.length - 1; i >= 1; i--) {
      const row = values[i];
      if (row[0].toLowerCase() === emailLower && 
          row[1].toLowerCase() === mapelLower && 
          String(row[2]) === taID) {
            
        MAPEL_SHEET.deleteRow(i + 1);
        rowDeleted = true;
        break;
      }
    }

    if (rowDeleted) {
       return { success: true, message: `Mapel ${key.mapel} berhasil dihapus.` };
    } else {
       return { error: `Mapel tidak ditemukan.` };
    }

  } catch (e) {
    Logger.log(e);
    return { error: `Terjadi kesalahan saat menghapus: ${e.toString()}` };
  } finally {
    lock.releaseLock();
  }
}

/**
 * ===== FUNGSI DATA (Langkah 4): Refactored (Hybrid) =====
 * Mengambil template nilai dari DB sekolah yang spesifik.
 * [MODIFIKASI V2] Menambahkan lookup jenjangPilihan dari App 1 DB.
 * @param {string} token - Token sesi.
 */
function superadmin_generateNilaiTemplate(token, id_sekolah, id_tahun_ajaran) {
  if (!id_sekolah || !id_tahun_ajaran) return { error: "Sekolah dan T.A. harus dipilih."};
  
  let tempSpreadsheetId = null;
  try {
    // 1. Verifikasi Superadmin
    _getVerifiedSessionData(token, 'superadmin');

    // 2. Dapatkan DB ID sekolah target
    const db_id = _getApp2DatabaseId(id_sekolah);
    const ss_sekolah = SpreadsheetApp.openById(db_id);
    
    // --- [MODIFIKASI V2] ---
    // 3. Dapatkan JenjangPilihan dari DB Aplikasi 1
    let jenjangPilihan = 'MA'; // Default
    let app1_db_id = null;
    try {
      const masterSS = SpreadsheetApp.openById(ID_MASTER_SHEET_APLIKASI_1);
      const sheetSekolah = masterSS.getSheetByName('Sheet_Sekolah');
      const data = sheetSekolah.getRange("A2:F" + sheetSekolah.getLastRow()).getValues();
      
      for (const row of data) {
        if (row[0] == id_sekolah) {
          app1_db_id = row[5]; // Kolom F
          break;
        }
      }
      
      if (app1_db_id) {
        const ss_app1 = SpreadsheetApp.openById(app1_db_id);
        
        // Helper untuk get 'Data_Sekolah' (disederhanakan dari App 1)
        const dataSekolahSheet = ss_app1.getSheetByName('Data_Sekolah');
        if (dataSekolahSheet) {
          jenjangPilihan = dataSekolahSheet.getRange('A2').getValue() || 'MA';
        } else {
           Logger.log(`Sheet 'Data_Sekolah' tidak ditemukan di ${app1_db_id}.`);
        }
      } else {
        Logger.log(`superadmin_generateNilaiTemplate: Gagal menemukan App1_DB_ID untuk ${id_sekolah}.`);
      }
    } catch(e) {
      Logger.log(`Error lookup jenjangPilihan di superadmin_generateNilaiTemplate: ${e.message}`);
    }
    const isKemenag = (jenjangPilihan === 'MI' || jenjangPilihan === 'MTS' || jenjangPilihan === 'MA');
    // --- [AKHIR MODIFIKASI V2] ---

    // 4. Ambil data T.A. & Sekolah dari DB GLOBAL
    const taRow = TAHUN_AJARAN_SHEET.getDataRange().getValues().find(row => row[0] == id_tahun_ajaran);
    const sekolahRow = SEKOLAH_SHEET.getDataRange().getValues().find(row => row[0] == id_sekolah);
    if (!taRow || !sekolahRow) throw new Error("TA atau Sekolah tidak valid.");
    const taDesc = taRow[1].replace('/', '-');
    const sekolahNama = sekolahRow[1];

    // 5. Ambil data guru dari DB GLOBAL
    const guruMap = GURU_SHEET.getDataRange().getValues().slice(1)
      .filter(row => row[3] == id_sekolah)
      .reduce((map, row) => { map[row[0].toLowerCase()] = row[2]; return map; }, {});
    const emailsInSchool = Object.keys(guruMap);

    // 6. Ambil data mapel dari DB SEKOLAH
    const mapelSheet = ss_sekolah.getSheetByName('db_mapel');
    if (!mapelSheet) throw new Error("'db_mapel' tidak ditemukan.");
    const mapelToGuruMap = {};
    const mapelHeaders = [];
    
    // [MODIFIKASI V2] Ambil flag isUS/isUP (Kolom F, G)
    mapelSheet.getDataRange().getValues().slice(1).forEach(row => {
      const emailGuruLower = row[0].toLowerCase();
      const idTA = String(row[2]);
      if (idTA === id_tahun_ajaran && emailsInSchool.includes(emailGuruLower)) {
        const namaMapel = row[1];
        if (!mapelToGuruMap[namaMapel]) {
          mapelToGuruMap[namaMapel] = {
            email: row[0],
            isUS: row[5] === true, // Kolom F
            isUP: row[6] === true  // Kolom G
          };
          mapelHeaders.push(namaMapel);
        }
      }
    });
    mapelHeaders.sort();

    // 7. Ambil data siswa dari DB SEKOLAH
    const siswaMap = ss_sekolah.getSheetByName('db_siswa').getDataRange().getValues().slice(1)
      .reduce((map, row) => { map[row[0]] = {nama: row[1], kelas: row[3] || 'N/A' }; return map; }, {}); // [MODIFIKASI] Ambil kelas
    const siswaList = ss_sekolah.getSheetByName('db_enrollment').getDataRange().getValues().slice(1)
      .filter(row => row[2] == id_sekolah && row[3] == id_tahun_ajaran)
      .map(row => ({ 
          no_ujian: row[1], 
          nama: siswaMap[row[1]] ? siswaMap[row[1]].nama : 'NAMA TIDAK ADA',
          kelas: siswaMap[row[1]] ? siswaMap[row[1]].kelas : 'N/A' // [MODIFIKASI] Ambil kelas
      }))
      .sort((a, b) => a.nama.localeCompare(b.nama));
      
    if (siswaList.length === 0) throw new Error("Tidak ada siswa terdaftar di TA/Sekolah ini.");
    if (mapelHeaders.length === 0) throw new Error("Tidak ada mapel terdaftar di TA/Sekolah ini.");

    // 8. Buat Template
    const tempSpreadsheet = SpreadsheetApp.create(`TEMP_NILAI_${sekolahNama}_${taDesc}`);
    tempSpreadsheetId = tempSpreadsheet.getId();
    const rule = SpreadsheetApp.newDataValidation().requireNumberBetween(0, 100).setAllowInvalid(true).build();
    
    // [MODIFIKASI V2] Filter mapel US/UP
    const mapelUS = mapelHeaders.filter(namaMapel => mapelToGuruMap[namaMapel].isUS);
    const mapelUP = mapelHeaders.filter(namaMapel => mapelToGuruMap[namaMapel].isUP);
    const dataSiswaRows = siswaList.map(s => [s.no_ujian, s.nama, s.kelas]); // [MODIFIKASI] Tambah kelas

    // Sheet 1: Ujian Madrasah / Ujian Sekolah
    const sheetUS = tempSpreadsheet.getSheets()[0];
    // [MODIFIKASI V2] Gunakan label dinamis
    const namaSheetUS = isKemenag ? 'Ujian Madrasah' : 'Ujian Sekolah';
    sheetUS.setName(namaSheetUS);
    sheetUS.getRange("A:A").setNumberFormat("@"); // Format No Ujian
    
    if (mapelUS.length > 0) {
      const headersUS = ["Nomor Ujian", "Nama Siswa", "Kelas", ...mapelUS]; // [MODIFIKASI] Tambah kelas
      sheetUS.getRange(1, 1, 1, headersUS.length).setValues([headersUS]).setFontWeight("bold");
      sheetUS.getRange(2, 1, dataSiswaRows.length, 3).setValues(dataSiswaRows); // [MODIFIKASI] Tulis 3 kolom
      sheetUS.getRange(2, 4, dataSiswaRows.length, mapelUS.length).setDataValidation(rule); // [MODIFIKASI] Mulai dari kolom 4
      sheetUS.autoResizeColumns(1, 3);
    } else {
      sheetUS.getRange('A1').setValue(`Tidak ada mapel untuk ${namaSheetUS}.`);
    }
    sheetUS.setFrozenRows(1);
    sheetUS.setFrozenColumns(3); // [MODIFIKASI] Bekukan 3 kolom

    // Sheet 2: Ujian Praktek
    const sheetUP = tempSpreadsheet.insertSheet('Ujian Praktek');
    sheetUP.getRange("A:A").setNumberFormat("@");
    if (mapelUP.length > 0) {
      const headersUP = ["Nomor Ujian", "Nama Siswa", "Kelas", ...mapelUP]; // [MODIFIKASI] Tambah kelas
      sheetUP.getRange(1, 1, 1, headersUP.length).setValues([headersUP]);
      sheetUP.getRange(2, 1, dataSiswaRows.length, 3).setValues(dataSiswaRows); // [MODIFIKASI] Tulis 3 kolom
      sheetUP.getRange(2, 4, dataSiswaRows.length, mapelUP.length).setDataValidation(rule); // [MODIFIKASI] Mulai dari kolom 4
      sheetUP.autoResizeColumns(1, 3);
    } else {
      sheetUP.getRange('A1').setValue('Tidak ada mapel untuk Ujian Praktek.');
    }
    sheetUP.setFrozenRows(1);
    sheetUP.setFrozenColumns(3); // [MODIFIKASI] Bekukan 3 kolom
    
    // Sheet 3: Metadata
    const metadataSheet = tempSpreadsheet.insertSheet("Metadata");
    const metadata = [
      ["id_sekolah", id_sekolah],
      ["id_tahun_ajaran", id_tahun_ajaran],
      ["[MAPEL_GUIDE]", "[EMAIL_GURU]"]
    ];
    mapelHeaders.forEach(mapel => metadata.push([mapel, mapelToGuruMap[mapel].email]));
    metadataSheet.getRange(1, 1, metadata.length, 2).setValues(metadata);
    metadataSheet.hideSheet();
    
    // Ekspor
    SpreadsheetApp.flush();
    const url = `https://docs.google.com/spreadsheets/d/${tempSpreadsheetId}/export?format=xlsx`;
    const response = UrlFetchApp.fetch(url, { headers: { Authorization: "Bearer " + ScriptApp.getOAuthToken() } });
    const base64Data = Utilities.base64Encode(response.getBlob().getBytes());
    return {
      success: true,
      base64Data: base64Data,
      fileName: `TEMPLATE_NILAI_${sekolahNama}_${taDesc}.xlsx`
    };

  } catch (e) {
    Logger.log(`Error di superadmin_generateNilaiTemplate: ${e.message}`);
    return { error: e.toString() };
  } finally {
    if (tempSpreadsheetId) try { DriveApp.getFileById(tempSpreadsheetId).setTrashed(true); } catch (err) {}
  }
}

/**
 * ===== FUNGSI DATA (Langkah 4): Refactored (Hybrid) =====
 * Memvalidasi file upload nilai (Superadmin).
 * @param {string} token - Token sesi.
 */
function superadmin_uploadNilaiFile(token, fileBase64, id_sekolah_filter, id_ta_filter, fileName) {
  if (!id_sekolah_filter || !id_ta_filter) return { success: false, errors: ["Filter Sekolah dan T.A. wajib dipilih."], fileName: fileName };
  
  let tempSpreadsheetId = null;
  let errors = [];
  try {
    // 1. Verifikasi Superadmin
    _getVerifiedSessionData(token, 'superadmin');
    
    // 2. Dapatkan DB ID sekolah target
    const db_id = _getApp2DatabaseId(id_sekolah_filter);
    const ss_sekolah = SpreadsheetApp.openById(db_id);

    // 3. Konversi file
    const fileBlob = Utilities.newBlob(Utilities.base64Decode(fileBase64.split(',')[1]), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", fileName);
    const resource = { title: `TEMP_VALIDASI_${fileName || Date.now()}`, mimeType: MimeType.GOOGLE_SHEETS };
    const driveFile = Drive.Files.insert(resource, fileBlob, { convert: true });
    tempSpreadsheetId = driveFile.id;
    const tempSpreadsheet = SpreadsheetApp.openById(tempSpreadsheetId);

    // 4. Validasi Metadata (dari file)
    const metadataSheet = tempSpreadsheet.getSheetByName("Metadata");
    if (!metadataSheet) throw new Error("Sheet 'Metadata' tidak ditemukan.");
    const metadata = metadataSheet.getDataRange().getValues();
    const id_sekolah_file = metadata[0][1];
    const id_ta_file = metadata[1][1];

    if (String(id_sekolah_file) !== String(id_sekolah_filter) || String(id_ta_file) !== String(id_ta_filter)) {
      throw new Error(`File ini dibuat untuk Sekolah/T.A. yang berbeda.`);
    }
    
    // 5. Dapatkan data siswa terdaftar (dari DB SEKOLAH)
    const enrollmentData = ss_sekolah.getSheetByName('db_enrollment').getDataRange().getValues().slice(1);
    const siswaData = ss_sekolah.getSheetByName('db_siswa').getDataRange().getValues().slice(1);
    const siswaMap = siswaData.reduce((map, row) => { map[row[0]] = row[1]; return map; }, {});
    const enrolledSiswaMap = enrollmentData
      .filter(row => row[2] == id_sekolah_file && row[3] == id_ta_file)
      .reduce((map, row) => {
        map[row[1]] = (siswaMap[row[1]] || 'N/A').toLowerCase();
        return map;
      }, {});
      
    if (Object.keys(enrolledSiswaMap).length === 0) {
       throw new Error("Data siswa terdaftar di server DB sekolah tidak ditemukan.");
    }

    // 6. Validasi Data Nilai (dari file)
    const dataSheet = tempSpreadsheet.getSheetByName("Data Nilai");
    if (!dataSheet) throw new Error("Sheet 'Data Nilai' tidak ditemukan.");
    
    const data = dataSheet.getDataRange().getValues();
    const headers = data[0];
    const mapelHeaders = headers.slice(2);
    const dataRows = data.slice(1);
    if (dataRows.length === 0) errors.push("Tidak ada data siswa di dalam file.");
    
    let rowCount = 0;
    dataRows.forEach((row, rowIndex) => {
      if (row[0] === '' && row[1] === '') return;
      const no_ujian = String(row[0]).trim();
      const nama_file = String(row[1]).trim().toLowerCase();
      if (!enrolledSiswaMap[no_ujian]) {
        errors.push(`Baris ${rowIndex + 2}: Nomor Ujian "${no_ujian}" tidak terdaftar.`);
      } else if (enrolledSiswaMap[no_ujian] !== nama_file) {
        errors.push(`Baris ${rowIndex + 2}: Nama siswa "${row[1]}" tidak cocok (Server: ${enrolledSiswaMap[no_ujian]}).`);
      }
      mapelHeaders.forEach((mapel, colIndex) => {
        const nilai = row[colIndex + 2];
        if (nilai !== "" && nilai !== null && (typeof nilai !== 'number' || nilai < 0 || nilai > 100)) {
          errors.push(`Baris ${rowIndex + 2} (${no_ujian}), Mapel "${mapel}": Nilai "${nilai}" tidak valid.`);
        }
      });
      rowCount++;
    });
    
    if (errors.length > 0) {
      return { success: false, errors: errors, fileName: fileName };
    }

    const entriNilaiCount = rowCount * mapelHeaders.length;
    return { 
      success: true, 
      message: `Validasi Berhasil. ${rowCount} siswa, ${mapelHeaders.length} mapel (${entriNilaiCount} entri nilai) dari file "${fileName}" siap disimpan.`,
      fileName: fileName 
    };

  } catch (e) {
    Logger.log(`Error di superadmin_uploadNilaiFile: ${e.message}`);
    errors.push(`Error internal server: ${e.toString()}`);
    return { success: false, errors: errors, fileName: fileName };
  } finally {
    if (tempSpreadsheetId) try { DriveApp.getFileById(tempSpreadsheetId).setTrashed(true); } catch (err) {}
  }
}

/**
 * ===== FUNGSI DATA (Langkah 4): Refactored (Hybrid) =====
 * Menyimpan file upload nilai (Superadmin) ke DB sekolah yang spesifik.
 * @param {string} token - Token sesi.
 */
function superadmin_saveUploadedNilai(token, fileBase64, id_sekolah_filter, id_ta_filter) {
  let tempSpreadsheetId = null;
  try {
    // 1. Verifikasi Superadmin
    _getVerifiedSessionData(token, 'superadmin');

    // 2. Dapatkan DB ID sekolah target
    const db_id = _getApp2DatabaseId(id_sekolah_filter);
    const ss_sekolah = SpreadsheetApp.openById(db_id);
    
    // 3. Cek Kunci T.A. di DB SEKOLAH
    if (isTahunAjaranLocked(id_ta_filter, ss_sekolah)) {
      return { error: "Gagal menyimpan. Tahun Ajaran ini telah dikunci." };
    }
    
    // 4. Lakukan Validasi Ulang (Wajib)
    const validation = superadmin_uploadNilaiFile(token, fileBase64, id_sekolah_filter, id_ta_filter, "file-saat-simpan");
    if (!validation.success) {
      return { error: `Validasi gagal: ${validation.errors[0]}` };
    }
    
    // 5. Jika Lolos, Parse ulang file untuk data
    const fileBlob = Utilities.newBlob(Utilities.base64Decode(fileBase64.split(',')[1]), "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    const resource = { title: `TEMP_SIMPAN_${id_sekolah_filter}_${id_ta_filter}_${Date.now()}`, mimeType: MimeType.GOOGLE_SHEETS };
    const driveFile = Drive.Files.insert(resource, fileBlob, { convert: true });
    tempSpreadsheetId = driveFile.id;
    const tempSpreadsheet = SpreadsheetApp.openById(tempSpreadsheetId);
    
    const metadataSheet = tempSpreadsheet.getSheetByName("Metadata");
    const metadata = metadataSheet.getRange(3, 1, metadataSheet.getLastRow() - 2, 2).getValues(); // Mulai dari baris 3
    const mapelToGuruMap = metadata.reduce((map, row) => {
      map[row[0]] = row[1]; // { "Matematika": "guru@email.com" }
      return map;
    }, {});
    
    const dataSheet = tempSpreadsheet.getSheetByName("Data Nilai");
    const data = dataSheet.getDataRange().getValues();
    const headers = data[0];
    const mapelHeaders = headers.slice(2);
    const siswaRows = data.slice(1);

    // 6. Transformasi Data & Panggil simpanAtauUpdateNilai per Mapel
    //    Kita harus memanggil simpanAtauUpdateNilai dengan 'token' palsu
    //    atau memodifikasinya agar menerima 'ss_sekolah'
    
    // --- Solusi: Panggil helper internalnya langsung ---
    const sheetNilai = getNilaiSheetByTahunAjaran(id_ta_filter, ss_sekolah);
    const allNilai = sheetNilai.getDataRange().getValues();
    const existingDataMap = allNilai.reduce((map, row, index) => {
      if (index > 0) { map[`${row[1]}_${row[2]}`] = index; } return map;
    }, {});
    // ---
    
    let totalProcessed = 0;
    let errors = [];

    mapelHeaders.forEach((mapel, index) => {
      const emailGuru = mapelToGuruMap[mapel];
      if (!emailGuru) {
        errors.push(`Mapel "${mapel}" tidak memiliki email guru di Metadata.`);
        return;
      }
      
      const colIndex = index + 2;
      
      siswaRows.filter(row => row[0] !== '' || row[1] !== '').forEach(row => {
        const nilai = row[colIndex];
        const nomorUjian = String(row[0]).trim();
        const key = `${nomorUjian}_${mapel}`;
        
        let nilaiBaru = null;
        if (nilai !== "" && nilai != null) {
          let num = parseFloat(nilai);
          if (!isNaN(num) && num >= 0 && num <= 100) nilaiBaru = num;
        }

        const rowIndex = existingDataMap[key];
        
        if (rowIndex !== undefined) {
          sheetNilai.getRange(rowIndex + 1, 4).setValue(nilaiBaru); // Kolom D = nilai
          sheetNilai.getRange(rowIndex + 1, 6).setValue(new Date()); // Kolom F = timestamp
        } else if (nilaiBaru !== null) {
          sheetNilai.appendRow([
            new Date().getTime(), "'" + nomorUjian, mapel, nilaiBaru,
            emailGuru, new Date(), id_ta_filter
          ]);
          // Update map agar append berikutnya tidak duplikat
          existingDataMap[key] = sheetNilai.getLastRow() - 1; 
        }
        totalProcessed++; // Hitung setiap sel yang diproses
      });
    });

    if (errors.length > 0) {
      throw new Error(errors.join('; '));
    }
    
    return { success: true, message: `Sukses! ${totalProcessed} entri nilai berhasil diupload/diperbarui.` };

  } catch (e) {
    Logger.log(`Error di superadmin_saveUploadedNilai: ${e.message}`);
    return { error: e.toString() };
  } finally {
    if (tempSpreadsheetId) try { DriveApp.getFileById(tempSpreadsheetId).setTrashed(true); } catch (err) {}
  }
}

/**
 * ===== FUNGSI DATA (Langkah 4): Refactored (Hybrid) =====
 * [MODIFIKASI] Mengambil rekapitulasi nilai untuk Superadmin.
 * SEKARANG HANYA MENGAMBIL NILAI YANG BERSTATUS "APPROVED".
 * [MODIFIKASI v2] Menerima filterKelas, memperbaiki urutan, dan mengembalikan allKelasList.
 * @param {string} token - Token sesi.
 */
function getRekapitulasiNilai(token, id_sekolah, id_ta_mulai, id_ta_akhir, mode, filterKelas) { // <-- MODIFIKASI: Tambah filterKelas
  try {
    // 1. Verifikasi Superadmin
    const { ss_sekolah } = _getVerifiedSessionData(token);
    
    if (!id_sekolah) {
      throw new Error("ID Sekolah tidak valid.");
    }

    // 2. Dapatkan rentang T.A. dari DB SEKOLAH
    const taSheet = ss_sekolah.getSheetByName('db_tahun_ajaran');
    if (!taSheet) throw new Error("'db_tahun_ajaran' tidak ditemukan.");
    const taData = taSheet.getDataRange().getValues();
    
    let startIndex = -1, endIndex = -1;
    for (let i = 1; i < taData.length; i++) {
      // Cari T.A. berdasarkan deskripsi (lebih aman jika ID berubah-ubah)
      if (taData[i][0] == id_ta_mulai) startIndex = i;
      if (taData[i][0] == id_ta_akhir) endIndex = i;
    }
    if (startIndex === -1 || endIndex === -1) throw new Error("ID T.A. Awal atau Akhir tidak ditemukan di DB sekolah.");
    
    // Balik jika urutannya salah
    if (startIndex > endIndex) [startIndex, endIndex] = [endIndex, startIndex];
    
    const taRange = taData.slice(startIndex, endIndex + 1);
    const taIdsToProcess = taRange.map(row => row[0]);

    // 3. Inisialisasi
    // const allStudents = {}; // (Diganti, lihat Loop 1)
    const allMapels = new Set();
    const nilaiData = {};
    
    // 4. Cache data master dari DB SEKOLAH
    // [MODIFIKASI] Ambil data lengkap siswa {nama, kelas, originalIndex}
    const allSiswaInSchoolMap = ss_sekolah.getSheetByName('db_siswa').getDataRange().getValues().slice(1)
      .reduce((map, row, index) => { 
        map[row[0]] = { // row[0] = nomor_ujian
          nama: row[1] || 'Nama Tdk Ditemukan',
          kelas: row[3] || 'N/A', // Kolom D (index 3)
          originalIndex: index // Simpan urutan asli dari sheet
        }; 
        return map; 
      }, {});
      
    // [BARU] Buat daftar kelas unik untuk dropdown filter
    const allKelasSet = new Set(Object.values(allSiswaInSchoolMap).map(siswa => siswa.kelas));
    const allKelasList = Array.from(allKelasSet).filter(k => k !== 'N/A').sort(compareKelas); // Gunakan helper sort
      
    const allEnrollments = ss_sekolah.getSheetByName('db_enrollment').getDataRange().getValues().slice(1)
      .filter(row => row[2] == id_sekolah); // Filter by school
      
    // 5. Ambil data guru dari DB GLOBAL
    const guruDiSekolahMap = GURU_SHEET.getDataRange().getValues().slice(1)
      .filter(row => row[3] == id_sekolah)
      .reduce((map, row) => { map[row[0].toLowerCase()] = row[2]; return map; }, {});
    const emailsGuruDiSekolah = Object.keys(guruDiSekolahMap);
      
    // 6. Cache Mapel Info (App 2) dan Status (App 2)
    const allMapelsInSchool = ss_sekolah.getSheetByName('db_mapel').getDataRange().getValues().slice(1)
      .filter(row => emailsGuruDiSekolah.includes(row[0].toLowerCase()));
      
    const mapelInfoMap = new Map(); // Kunci: namaMapel
    const mapelLegenda = {};

    allMapelsInSchool.forEach(m_row => {
        const namaMapel = m_row[1];
        if (!mapelInfoMap.has(namaMapel)) {
            const singkatan = m_row[3] ? String(m_row[3]).toUpperCase() : String(namaMapel).substring(0,5).toUpperCase();
            mapelInfoMap.set(namaMapel, {
                id: namaMapel,
                nama: namaMapel,
                singkatan: singkatan,
                isUS: m_row[5] === true, // Kolom F
                isUP: m_row[6] === true  // Kolom G
            });
            // Pastikan singkatan unik
            if (mapelLegenda[singkatan] && mapelLegenda[singkatan] !== namaMapel) {
              mapelLegenda[`${singkatan}2`] = namaMapel;
              mapelInfoMap.get(namaMapel).singkatan = `${singkatan}2`;
            } else {
              mapelLegenda[singkatan] = namaMapel;
            }
        }
    });

    // 7. Ambil data status kirim (Approved)
    const statusSheet = getStatusKirimSheet(ss_sekolah);
    const statusData = statusSheet.getDataRange().getValues().slice(1);
    const approvedSet = new Set();
    
    statusData.forEach(row => {
        const status = row[6]; // Kolom G (status_approval)
        if (status === 'APPROVED' || status === 'APPROVED_NOTIFIED') {
            const key = `${row[2].toLowerCase()}_${row[3]}_${row[1]}`; 
            approvedSet.add(key);
        }
    });

    // ===============================================================
    // Loop 1: Kumpulkan semua siswa, mapel, dan data nilai
    // ===============================================================
    const enrollmentByTA = {};
    
    // [MODIFIKASI] Ganti allStudents (Map) menjadi allStudentsList (Array)
    const allStudentsList = []; // Array, not map
    const allStudentsSet = new Set(); // To track duplicates
    
    taIdsToProcess.forEach(id_ta => {
      
      const enrolledSiswaThisTA = new Set();
      allEnrollments.filter(e_row => e_row[3] == id_ta) // Filter by TA
        .forEach(e_row => {
          const no_ujian = e_row[1];
          enrolledSiswaThisTA.add(no_ujian);
          
          // [MODIFIKASI] Logika untuk mode 'single'
          if (mode === 'single' && !allStudentsSet.has(no_ujian) && allSiswaInSchoolMap[no_ujian]) {
            allStudentsSet.add(no_ujian);
            allStudentsList.push({
              no_ujian: no_ujian, // <-- Tambahkan kunci (Nomor Ujian)
              ...allSiswaInSchoolMap[no_ujian] // { nama, kelas, originalIndex }
            });
          }
        });
      enrollmentByTA[id_ta] = enrolledSiswaThisTA;

      // Tambahkan mapel ke 'allMapels' Set
      allMapelsInSchool.filter(m_row => m_row[2] == id_ta)
        .forEach(m_row => {
          allMapels.add(m_row[1]);
        });
        
      const NILAI_SHEET = getNilaiSheetByTahunAjaran(id_ta, ss_sekolah);
      const nilaiValues = NILAI_SHEET.getDataRange().getValues().slice(1);
      const taNilaiMap = {};
      
      // [MODIFIKASI INTI] (Logika ini sudah benar)
      nilaiValues.forEach(n_row => {
        const no_ujian = n_row[1];
        const mapel = n_row[2];
        const emailGuru = n_row[5] ? n_row[5].toLowerCase() : '';

        if (enrolledSiswaThisTA.has(no_ujian)) {
            const statusKey = `${emailGuru}_${mapel}_${id_ta}`;
            if (approvedSet.has(statusKey)) {
                
                const nilaiUjian = (n_row[3] !== '' && n_row[3] !== null) ? parseFloat(n_row[3]) : null;
                const nilaiPraktek = (n_row[4] !== '' && n_row[4] !== null) ? parseFloat(n_row[4]) : null;
                const mapelInfo = mapelInfoMap.get(mapel);
                const showUS = mapelInfo ? mapelInfo.isUS : true; 
                const showUP = mapelInfo ? mapelInfo.isUP : false;

                let nilaiFinal = null;
                const nU = (showUS && nilaiUjian !== null && !isNaN(nilaiUjian)) ? nilaiUjian : null;
                const nP = (showUP && nilaiPraktek !== null && !isNaN(nilaiPraktek)) ? nilaiPraktek : null;

                if (nU !== null && nP !== null) nilaiFinal = (nU + nP) / 2;
                else if (nU !== null) nilaiFinal = nU;
                else if (nP !== null) nilaiFinal = nP;
                
                if (nilaiFinal !== null) {
                    if (!taNilaiMap[no_ujian]) taNilaiMap[no_ujian] = {};
                    taNilaiMap[no_ujian][mapel] = Math.round(nilaiFinal);
                }
            }
        }
      });
      // [AKHIR MODIFIKASI INTI]

      nilaiData[id_ta] = taNilaiMap;
    }); // Akhir loop taIdsToProcess

    // ===============================================================
    // Loop 2: Bangun Tabel
    // ===============================================================
    const sortedMapels = Array.from(allMapels).sort();
    
    const sortedAbbreviations = sortedMapels.map(m => {
        const info = mapelInfoMap.get(m);
        const singkatan = info ? info.singkatan : m.substring(0,5).toUpperCase();
        // Pastikan singkatan unik (jika ada duplikat, tambahkan angka)
        if (mapelLegenda[singkatan] && mapelLegenda[singkatan] !== m) {
            const newSingkatan = `${singkatan}2`;
            mapelLegenda[newSingkatan] = m;
            return newSingkatan;
        }
        mapelLegenda[singkatan] = m;
        return singkatan;
    });

    let tableHeaders = [];
    let tableRows = [];

    if (mode === 'single') {
      
      // [MODIFIKASI] Terapkan filter dan urutan
      let studentList = allStudentsList;
      
      // 1. Terapkan Filter Kelas
      if (filterKelas && filterKelas !== 'semua') {
        studentList = studentList.filter(siswa => siswa.kelas === filterKelas);
      }
      
      // 2. Terapkan Urutan
      studentList.sort((a, b) => {
        const compareKelasVal = compareKelas(a.kelas, b.kelas); // Gunakan helper compareKelas
        if (compareKelasVal !== 0) return compareKelasVal;
        return a.originalIndex - b.originalIndex; // Urutan asli dari db_siswa
      });
      // [AKHIR MODIFIKASI]
      
      tableHeaders = ['No', 'Nama Siswa', 'Kelas', ...sortedAbbreviations, 'Jumlah', 'Rata-2']; // <-- MODIFIKASI: Tambah 'Kelas'
      
      studentList.forEach((siswa, index) => { // <-- MODIFIKASI: Gunakan studentList
        const no_ujian = siswa.no_ujian;
        const namaSiswa = siswa.nama;
        let row = { 
          'No': index + 1, 
          'Nama Siswa': namaSiswa.toUpperCase(),
          'Kelas': siswa.kelas // <-- MODIFIKASI: Tambah data 'Kelas'
        };
        let studentTotalNilai = 0;
        let studentCountNilai = 0;
        
        sortedMapels.forEach((mapel, i_mapel) => {
          const abbr = sortedAbbreviations[i_mapel];
          let mapelSum = 0;
          let mapelCount = 0;
          
          taIdsToProcess.forEach(id_ta => {
            if (nilaiData[id_ta] && nilaiData[id_ta][no_ujian] && nilaiData[id_ta][no_ujian][mapel]) {
              mapelSum += nilaiData[id_ta][no_ujian][mapel];
              mapelCount++;
            }
          });
          
          const mapelAverage = (mapelCount > 0) ? (mapelSum / mapelCount) : null;
          const displayNilai = mapelAverage ? Math.round(mapelAverage) : '';
          row[abbr] = displayNilai;
          
          if (mapelAverage !== null) {
            studentTotalNilai += mapelAverage;
            studentCountNilai++;
          }
        });
        
        row['Jumlah'] = Math.round(studentTotalNilai);
        row['Rata-2'] = (studentCountNilai > 0) ? Math.round(studentTotalNilai / studentCountNilai) : '';
        tableRows.push(row);
      });

    } 
    else if (mode === 'range') {
      tableHeaders = ['Tahun Ajaran', ...sortedAbbreviations, 'Jumlah', 'Rata-2'];
      
      taRange.forEach(ta_row => {
        const id_ta = ta_row[0];
        const deskripsi_ta = ta_row[1];
        let row = { 'Tahun Ajaran': deskripsi_ta };
        const taNilaiMap = nilaiData[id_ta];
        const enrolledSiswaThisTA = enrollmentByTA[id_ta];
        let rowTotalNilai = 0;
        let rowCountNilai = 0;
        
        sortedMapels.forEach((mapel, i_mapel) => {
          const abbr = sortedAbbreviations[i_mapel];
          let mapelSum = 0;
          let mapelCount = 0;
          
          enrolledSiswaThisTA.forEach(no_ujian => {
             if (taNilaiMap[no_ujian] && taNilaiMap[no_ujian][mapel]) {
                mapelSum += taNilaiMap[no_ujian][mapel];
                mapelCount++;
             }
          });
          
          const mapelAverage = (mapelCount > 0) ? (mapelSum / mapelCount) : null;
          const displayNilai = mapelAverage ? Math.round(mapelAverage) : '';
          row[abbr] = displayNilai;
          
          if (mapelAverage !== null) {
            rowTotalNilai += mapelAverage;
            rowCountNilai++;
          }
        });
        
        row['Jumlah'] = Math.round(rowTotalNilai);
        row['Rata-2'] = (rowCountNilai > 0) ? Math.round(rowTotalNilai / rowCountNilai) : '';
        tableRows.push(row);
      });
    }

    return { 
      success: true, 
      headers: tableHeaders, 
      rows: tableRows, 
      legenda: mapelLegenda,
      allKelasList: allKelasList // <-- MODIFIKASI: Kirim daftar kelas
    };

  } catch (e) {
    Logger.log(`Error di getRekapitulasiNilai (SA): ${e.message} \n ${e.stack}`);
    return { error: e.toString(), allKelasList: [] }; // Kirim array kosong jika error
  }
}

/**
 * ===== FUNGSI DATA (Langkah 4): Refactored (Hybrid) =====
 * Mengekspor rekap ke Excel.
 * @param {string} token - Token sesi.
 */
function exportRekapToExcel_Backend(token, id_sekolah, id_ta_mulai, id_ta_akhir, mode) {
  try {
    // 1. Verifikasi Superadmin
    _getVerifiedSessionData(token);
    
    // 2. Panggil getRekapitulasiNilai (sudah di-refactor)
    const rekapData = getRekapitulasiNilai(token, id_sekolah, id_ta_mulai, id_ta_akhir, mode);
    if (rekapData.error) return rekapData; 

    const { headers, rows } = rekapData;
    if (rows.length === 0) return { error: "Tidak ada data untuk diekspor." };
    let tempSpreadsheetId = null;
    const excelFileName = `Rekapitulasi Nilai (${mode}) ${new Date().toLocaleString('id-ID')}.xlsx`;
    try {
      const ss = SpreadsheetApp.create(`TEMP_EXCEL_${Date.now()}`);
      tempSpreadsheetId = ss.getId();
      const sheet = ss.getActiveSheet();
      sheet.setName("Rekap Nilai");
      const headerRange = sheet.getRange(1, 1, 1, headers.length);
      headerRange.setValues([headers]);
      headerRange.setFontWeight("bold");
      sheet.setFrozenRows(1);
      const dataArray = rows.map(rowObject => headers.map(header => rowObject[header] !== undefined ? rowObject[header] : ''));
      sheet.getRange(2, 1, dataArray.length, headers.length).setValues(dataArray);
      sheet.autoResizeColumns(1, headers.length);
      SpreadsheetApp.flush();
      const url = `https://docs.google.com/spreadsheets/d/${tempSpreadsheetId}/export?format=xlsx`;
      const params = { method: "GET", headers: { "Authorization": "Bearer " + ScriptApp.getOAuthToken() }, muteHttpExceptions: true };
      const response = UrlFetchApp.fetch(url, params);
      if (response.getResponseCode() !== 200) throw new Error(`Gagal fetch Excel: ${response.getContentText()}`);
      const excelBlob = response.getBlob();
      const base64Data = Utilities.base64Encode(excelBlob.getBytes());
      return { success: true, base64Data: base64Data, fileName: excelFileName };
    } catch (e) {
      throw e; // Lemparkan ke catch utama
    } finally {
      if (tempSpreadsheetId) DriveApp.getFileById(tempSpreadsheetId).setTrashed(true);
    }
  } catch (e) {
    Logger.log(`Error di exportRekapToExcel_Backend: ${e.message}`);
    return { error: `Gagal membuat file Excel: ${e.toString()}` };
  }
}

/**
 * ===== FUNGSI DATA (Langkah 4): Refactored (HTML to PDF) =====
 * Mengekspor rekap ke PDF menggunakan HTML Service.
 * [MODIFIKASI] 
 * 1. Judul dengan Nama Sekolah.
 * 2. Kepsek & NIP dari DB Aplikasi 1 (Data_Sekolah Kolom O & P).
 * 3. Tempat & Tanggal dari Master Sheet (Pengaturan Cetak).
 * @param {string} token - Token sesi.
 */
function exportRekapToPdf_Backend(token, id_sekolah, id_ta_mulai, id_ta_akhir, mode) {
  try {
    // 1. Verifikasi Sesi untuk mendapatkan ID Database App 1
    const session = _getVerifiedSessionData(token);
    const app1_db_id = session.app1_db_id; // ID Database Sekolah
    
    // 2. Ambil Data Rekapitulasi (Nilai)
    const rekapData = getRekapitulasiNilai(token, id_sekolah, id_ta_mulai, id_ta_akhir, mode);
    if (rekapData.error) return rekapData;
    const { headers, rows, legenda } = rekapData; 
    if (rows.length === 0) return { error: "Tidak ada data untuk diekspor." };

    // --- BAGIAN PENGAMBILAN DATA HEADER & FOOTER ---

    let namaSekolah = 'SEKOLAH';
    let tempatTtd = 'Belum Diatur';
    let kepalaSekolah = 'Belum Diatur';
    let nipKepsek = '-';
    let tanggalStr = '';
    let kopBase64 = null;

    // A. AMBIL NAMA SEKOLAH, TEMPAT, TANGGAL, KOP SURAT DARI MASTER SHEET (Pengaturan Cetak)
    try {
      const masterSS = SpreadsheetApp.openById(ID_MASTER_SHEET_APLIKASI_1);
      const sheetSekolahMaster = masterSS.getSheetByName('Sheet_Sekolah');
      const dataMaster = sheetSekolahMaster.getDataRange().getValues();
      
      // Cari baris sekolah berdasarkan ID (Kolom A)
      const rowMaster = dataMaster.find(r => r[0] == id_sekolah);
      
      if (rowMaster) {
        namaSekolah = rowMaster[1]; // Kolom B (Nama Sekolah)
        tempatTtd = rowMaster[19] || 'Belum Diatur'; // Kolom T (Tempat TTD)
        
        // Logika Tanggal (Manual vs Otomatis)
        const tglManual = rowMaster[16]; // Kolom Q (Tanggal Cetak)
        const modeTgl = rowMaster[20];   // Kolom U (Mode Tanggal)
        
        let dateObj = new Date(); // Default hari ini
        if (modeTgl === 'manual' && tglManual instanceof Date) {
           dateObj = tglManual;
        }
        // Format Tanggal Indonesia (dd MMMM yyyy)
        tanggalStr = dateObj.toLocaleDateString('id-ID', { day: 'numeric', month: 'long', year: 'numeric' });

        // Ambil Kop Surat (Kolom P)
        if (rowMaster[15]) { 
           kopBase64 = _getImageAsBase64DataUrl(rowMaster[15]);
        }
      }
    } catch (e) {
      Logger.log("Error ambil data Master Sheet: " + e.message);
    }

    // B. AMBIL KEPALA SEKOLAH & NIP DARI DB APLIKASI 1 (Data_Sekolah: Kolom O & P)
    if (app1_db_id) {
      try {
        const ss1 = SpreadsheetApp.openById(app1_db_id);
        const sheetDS = ss1.getSheetByName('Data_Sekolah');
        if (sheetDS) {
           // Kolom O = Index 15, Kolom P = Index 16 (di spreadsheet 1-based) -> O2:P2
           const dsValues = sheetDS.getRange('O2:P2').getValues()[0];
           if (dsValues[0]) kepalaSekolah = dsValues[0];
           if (dsValues[1]) nipKepsek = dsValues[1];
        }
      } catch (e) {
        Logger.log("Error ambil Kepsek dari App 1: " + e.message);
      }
    }

    // -----------------------------------------------

    // 4. Siapkan Deskripsi Judul (Tahun Ajaran)
    const ss_sekolah = _getApp2DatabaseId(id_sekolah) ? SpreadsheetApp.openById(_getApp2DatabaseId(id_sekolah)) : null;
    let deskripsiRekap = "";
    if (ss_sekolah) {
       const taSheet = ss_sekolah.getSheetByName('db_tahun_ajaran');
       const taData = taSheet.getDataRange().getValues();
       const taMulaiRow = taData.find(r => r[0] == id_ta_mulai);
       const taAkhirRow = taData.find(r => r[0] == id_ta_akhir);
       
       if (mode === 'single') {
         deskripsiRekap = `TAHUN AJARAN ${taMulaiRow ? taMulaiRow[1] : id_ta_mulai}`;
       } else {
         deskripsiRekap = `RENTANG TAHUN ${taMulaiRow ? taMulaiRow[1] : id_ta_mulai} S.D. ${taAkhirRow ? taAkhirRow[1] : id_ta_akhir}`;
       }
    }

    // 5. Generate HTML Header (Kop Surat / Nama Sekolah)
    let headerHtml = '';
    if (kopBase64) {
       headerHtml = `<div style="width: 100%; margin-bottom: 10px; border-bottom: 3px solid black; text-align: center;">
                       <img src="${kopBase64}" style="width: 100%; max-height: 150px; object-fit: contain;">
                     </div>`;
    } else {
       headerHtml = `<div style="text-align: center; margin-bottom: 20px; border-bottom: 3px solid black; padding-bottom: 10px;">
                       <h2 style="margin:0;">${namaSekolah.toUpperCase()}</h2>
                     </div>`;
    }

    // 6. Generate HTML Tabel Data
    let tableHeaderHtml = '<thead><tr>';
    headers.forEach(h => {
       tableHeaderHtml += `<th>${h}</th>`;
    });
    tableHeaderHtml += '</tr></thead>';

    let tableBodyHtml = '<tbody>';
    rows.forEach((row, idx) => {
       tableBodyHtml += '<tr>';
       headers.forEach(h => {
          let val = (row[h] !== undefined && row[h] !== null) ? row[h] : '';
          let align = 'center';
          if (h === 'Nama Siswa') align = 'left';
          let style = '';
          if (h === 'Rata-2' || h === 'Jumlah') style = 'font-weight: bold; background-color: #f8f9fa;';
          
          tableBodyHtml += `<td style="text-align: ${align}; ${style}">${val}</td>`;
       });
       tableBodyHtml += '</tr>';
    });
    tableBodyHtml += '</tbody>';

    // 7. Generate HTML Legenda
    let legendaHtml = '';
    if (legenda && Object.keys(legenda).length > 0) {
       legendaHtml = '<div style="margin-top: 10px; font-size: 8pt; border: 1px solid #ccc; padding: 5px;"><strong>Keterangan Mata Pelajaran:</strong><br>';
       const sortedKeys = Object.keys(legenda).sort();
       let items = [];
       sortedKeys.forEach(key => {
          items.push(`<b>${key}</b>: ${legenda[key]}`);
       });
       legendaHtml += items.join(', ') + '</div>';
    }

    // 8. Susun HTML Lengkap
    const htmlContent = `
      <html>
      <head>
        <style>
          @page { size: A4 landscape; margin: 1cm; }
          body { font-family: Arial, sans-serif; font-size: 10pt; }
          
          table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 9pt; }
          th, td { border: 1px solid black; padding: 4px; vertical-align: middle; }
          th { background-color: #e0e0e0; text-align: center; font-weight: bold; }
          
          .title-section { text-align: center; margin-bottom: 20px; margin-top: 10px; }
          .title-main { font-size: 14pt; font-weight: bold; text-decoration: underline; text-transform: uppercase; }
          .title-sub { font-size: 12pt; font-weight: bold; margin-top: 5px; text-transform: uppercase; }
          
          .footer-section { width: 100%; margin-top: 30px; page-break-inside: avoid; }
          .ttd-box { width: 300px; float: right; text-align: center; }
        </style>
      </head>
      <body>
        ${headerHtml}
        
        <div class="title-section">
           <div class="title-main">REKAPITULASI NILAI SISWA ${namaSekolah.toUpperCase()}</div>
           <div class="title-sub">${deskripsiRekap}</div>
        </div>

        <table>
          ${tableHeaderHtml}
          ${tableBodyHtml}
        </table>
        
        ${legendaHtml}

        <div class="footer-section">
           <div class="ttd-box">
              <p>${tempatTtd}, ${tanggalStr}<br>Kepala Sekolah,</p>
              <br><br><br><br>
              <p style="font-weight: bold; text-decoration: underline;">${formatNamaGelar(kepalaSekolah)}</p>
              <p>NIP. ${nipKepsek}</p>
           </div>
           <div style="clear: both;"></div>
        </div>
      </body>
      </html>
    `;

    // 9. Konversi ke PDF
    const pdfBlob = Utilities.newBlob(htmlContent, MimeType.HTML).getAs(MimeType.PDF);
    const base64Data = Utilities.base64Encode(pdfBlob.getBytes());
    const finalFileName = `Rekapitulasi_${namaSekolah}_${mode}.pdf`;

    return { success: true, base64Data: base64Data, fileName: finalFileName };

  } catch (e) {
    Logger.log(`Error di exportRekapToPdf_Backend: ${e.message}`);
    return { error: `Gagal membuat file PDF: ${e.toString()}` };
  }
}

// --- [TAMBAHKAN FUNGSI INI di aplikasi2/Kode.gs.html] ---

/**
 * [HELPER BARU]
 * Fungsi ini dijalankan SATU KALI secara manual dari editor
 * untuk membuat sheet cache token.
 */
function _buatSheetOttCache() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let sheet = ss.getSheetByName('db_ott_cache');
  if (!sheet) {
    sheet = ss.insertSheet('db_ott_cache');
    sheet.appendRow(['Token', 'EmailPayload', 'Timestamp']);
    sheet.setFrozenRows(1);
    SpreadsheetApp.flush();
    Logger.log("Sheet 'db_ott_cache' berhasil dibuat.");
  } else {
    Logger.log("Sheet 'db_ott_cache' sudah ada.");
  }
}

/**
 * [HELPER BARU]
 * Mengambil atau membuat sheet cache token.
 */
function getOttCacheSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName('db_ott_cache');
  if (!sheet) {
    // Jika tidak ada, buat secara otomatis (walaupun sebaiknya jalankan manual)
    return _buatSheetOttCache();
  }
  return sheet;
}

function getSekolahDatabaseId(token) {
  const properties = PropertiesService.getScriptProperties();
  const authKey = 'auth_' + token;
  const authDataString = properties.getProperty(authKey);
  if (!authDataString) throw new Error("Sesi tidak valid.");

  const authData = JSON.parse(authDataString);

  if (authData.db_id) {
    return authData.db_id; // Kembalikan ID yang sudah di-cache di session
  }

  // --- Fallback: Jika db_id tidak ada di session (mis. sesi lama) ---
  if (!authData.id_sekolah) throw new Error("Sesi tidak memiliki id_sekolah.");

  const masterSS = SpreadsheetApp.openById(ID_MASTER_SHEET_APLIKASI_1);
  const sheetSekolah = masterSS.getSheetByName('Sheet_Sekolah');
  const data = sheetSekolah.getRange("A2:M" + sheetSekolah.getLastRow()).getValues();

  for (const row of data) {
    if (row[0] == authData.id_sekolah) { // Kolom A
      const app2_db_id = row[12]; // Kolom M
      if (!app2_db_id) throw new Error("Database sekolah (Kolom M) tidak ditemukan di Master Sheet.");

      // Simpan ke session untuk nanti
      authData.db_id = app2_db_id;
      properties.setProperty(authKey, JSON.stringify(authData));

      return app2_db_id;
    }
  }

  throw new Error("ID Sekolah tidak ditemukan di Master Sheet.");
}

function _getApp2DatabaseId(id_sekolah) {
  // 1. Cek Cache Global terlebih dahulu
  const cacheKey = 'MAP_DB_ID_' + id_sekolah;
  const scriptCache = CacheService.getScriptCache();
  const cachedId = scriptCache.get(cacheKey);

  if (cachedId) {
    return cachedId; // KEMBALIKAN DARI CACHE (Cepat!)
  }

  // 2. Jika tidak ada di cache, baru buka Master Sheet (Lambat)
  // Gunakan Lock untuk mencegah "thundering herd" (banyak request buka sheet bersamaan)
  const lock = LockService.getScriptLock();
  try {
    // Tunggu sebentar, mungkin proses lain sudah mengisi cache
    lock.waitLock(5000); 
    
    // Cek cache lagi setelah mendapatkan lock
    const doubleCheck = scriptCache.get(cacheKey);
    if (doubleCheck) return doubleCheck;

    try {
      const masterSS = SpreadsheetApp.openById(ID_MASTER_SHEET_APLIKASI_1);
      const sheetSekolah = masterSS.getSheetByName('Sheet_Sekolah');
      if (!sheetSekolah) throw new Error("Sheet_Sekolah tidak ditemukan.");
      
      // Optimasi: Ambil hanya kolom A (ID) dan M (App2_ID) untuk mempercepat
      const data = sheetSekolah.getDataRange().getValues(); 
      
      let foundId = null;
      
      // Loop data untuk mencari dan sekaligus cache sekolah lain (Pre-caching)
      // Ini trik agar pembacaan berikutnya untuk sekolah lain tidak perlu buka sheet lagi
      const cacheMap = {};

      for (let i = 1; i < data.length; i++) {
        const rowIdSekolah = data[i][0];
        const rowDbId = data[i][12]; // Kolom M

        if (rowIdSekolah && rowDbId) {
           cacheMap['MAP_DB_ID_' + rowIdSekolah] = rowDbId;
           if (rowIdSekolah == id_sekolah) {
             foundId = rowDbId;
           }
        }
      }

      // Simpan semua ID yang ditemukan ke cache selama 6 jam (21600 detik)
      if (Object.keys(cacheMap).length > 0) {
        scriptCache.putAll(cacheMap, 21600);
      }
      
      if (foundId) {
        return foundId;
      }
      
      throw new Error(`ID Sekolah ${id_sekolah} tidak ditemukan atau DB App 2 kosong.`);
      
    } catch (e) {
      Logger.log(`Error Kritis di _getApp2DatabaseId: ${e.message}`);
      throw e; 
    }
  } catch (e) {
     throw e;
  } finally {
    lock.releaseLock();
  }
}

/**
 * [MODIFIKASI SESUAI ANALISIS]
 * Memvalidasi sesi guru. Fungsi ini dibuat "ringan" dan
 * mengandalkan data sesi yang disimpan saat login.
 * Membuka 2 Spreadsheet: 1 (Global Guru DB) + 1 (DB Lokal Sekolah).
 * Gagal jika sesi tidak memiliki ID DB (memaksa login ulang).
 */
function _getVerifiedSessionData(token, requiredRole = null) {
  const properties = PropertiesService.getScriptProperties();
  const authKey = 'auth_' + token;
  const authDataString = properties.getProperty(authKey);
  
  if (!authDataString) throw new Error("Sesi tidak valid (token tidak ditemukan). Silakan login ulang.");
  
  const authData = JSON.parse(authDataString);
  
  // 1. Validasi Waktu (Cepat, tidak ada panggilan server)
  const TOKEN_EXPIRATION_MS = 30 * 24 * 60 * 60 * 1000; // 30 hari
  const now = new Date().getTime();
  const tokenAge = now - authData.timestamp;
  if (tokenAge > TOKEN_EXPIRATION_MS) {
    properties.deleteProperty(authKey);
    properties.deleteProperty('token_' + authData.email);
    throw new Error("Sesi kedaluwarsa. Silakan login ulang.");
  }
  
  // 2. Validasi Data Sesi (BARU, Cepat, tidak ada panggilan server)
  // Cek apakah data penting (yang disimpan saat login) ada.
  // Jika tidak, ini adalah sesi lama atau korup. Paksa login ulang.
  if (!authData.db_id || !authData.app1_db_id || !authData.id_sekolah || !authData.jenjangPilihan) {
      properties.deleteProperty(authKey); // Hapus sesi korup
      properties.deleteProperty('token_' + authData.email);
      throw new Error("Sesi Anda tidak lengkap (mungkin sesi lama). Silakan login ulang untuk memperbarui.");
  }

  // 3. Validasi Guru (OPTIMASI CACHE)
  const cacheKey = 'USER_PROFILE_' + authData.email;
  const cache = CacheService.getScriptCache();
  const cachedProfile = cache.get(cacheKey);
  
  let guruInfo = null;

  if (cachedProfile) {
    // HIT: Ambil dari cache (Cepat, tanpa baca Spreadsheet)
    guruInfo = JSON.parse(cachedProfile);
  } else {
    // MISS: Baca dari Spreadsheet (Lambat, memakan kuota)
    const dataGuru = GURU_SHEET.getDataRange().getValues();
    for (let i = 1; i < dataGuru.length; i++) {
      if (dataGuru[i][0].toLowerCase() === authData.email) {
        guruInfo = {
          email: dataGuru[i][0],
          nama: dataGuru[i][2],
          id_sekolah: dataGuru[i][3],
          role: dataGuru[i][4] || 'guru'
        };
        break;
      }
    }
    
    if (guruInfo) {
      // Simpan ke cache selama 20 menit (1200 detik)
      // Ini mengurangi beban read spreadsheet secara drastis
      cache.put(cacheKey, JSON.stringify(guruInfo), 1200);
    }
  }
  
  if (!guruInfo) throw new Error("Akun guru tidak lagi ditemukan di database global.");
  
  // Keamanan tambahan: Cek jika ID sekolah di sesi masih sama dengan di DB
  if (guruInfo.id_sekolah != authData.id_sekolah) {
      throw new Error("Data sekolah Anda berubah. Silakan login ulang.");
  }

  // 4. Cek Role (Cepat)
  if (requiredRole && guruInfo.role !== requiredRole) {
    throw new Error(`Akses ditolak. Memerlukan role '${requiredRole}'.`);
  }
  
  // 5. Buka DB Lokal Sekolah (PANGGILAN SPREADSHEET #2 - DB Sekolah)
  // Kita gunakan 'authData.db_id' yang didapat dari sesi (cache).
  const ss_sekolah = SpreadsheetApp.openById(authData.db_id);
  
  // 6. Cek Notifikasi Status (Opsional, hanya untuk guru)
  let approvalStatusList = [];
  if (guruInfo.role === 'guru') {
    try {
      const statusSheet = getStatusKirimSheet(ss_sekolah);
      const dataRange = statusSheet.getDataRange();
      const statusData = dataRange.getValues();
      let changesMade = false;
      
      for (let i = 1; i < statusData.length; i++) {
        const row = statusData[i];
        const email = row[2];
        const status = row[6];
        
        if (email.toLowerCase() === authData.email) {
          if (status === "APPROVED") {
            approvalStatusList.push({ mapel: row[3], status: "APPROVED", alasan: "" });
            statusData[i][6] = "APPROVED_NOTIFIED";
            changesMade = true;
          } else if (status === "REJECTED") {
            approvalStatusList.push({ mapel: row[3], status: "REJECTED", alasan: row[7] || "Tidak ada alasan." });
            statusData[i][6] = "REJECTED_NOTIFIED";
            changesMade = true;
          }
        }
      }
      
      if (changesMade) {
        dataRange.setValues(statusData);
        SpreadsheetApp.flush();
      }
    } catch (e) {
      Logger.log("Gagal mengambil notifikasi persetujuan (tidak fatal): " + e.message);
    }
  }
  
  // 7. Perbarui timestamp sesi (Cepat)
  authData.timestamp = now;
  properties.setProperty(authKey, JSON.stringify(authData));
  
  // 8. Kembalikan semua data yang sudah tervalidasi
  return {
    authData: authData,
    ss_sekolah: ss_sekolah, // Objek Spreadsheet App 2 (Lokal)
    role: guruInfo.role,
    email: guruInfo.email,
    nama: guruInfo.nama,
    id_sekolah: guruInfo.id_sekolah,
    db_id: authData.db_id, // ID Spreadsheet App 2 (Lokal)
    app1_db_id: authData.app1_db_id, // ID Spreadsheet App 1 (Lokal)
    jenjangPilihan: authData.jenjangPilihan,
    approvalStatusList: approvalStatusList
  };
}

/**
 * [BARU] Helper untuk mengelola sheet db_pengaturan_katrol.
 * Memigrasi dari 2 kolom (Min, Maks) ke 4 kolom (Min_Uj, Maks_Uj, Min_Pr, Maks_Pr).
 */
function _getPengaturanKatrolSheet(ss_sekolah) {
  const sheetName = 'db_pengaturan_katrol';
  let sheet = ss_sekolah.getSheetByName(sheetName);

  if (!sheet) {
    sheet = ss_sekolah.insertSheet(sheetName);
    const headers = [
      "email", "id_tahun_ajaran", 
      "min_hasil_ujian", "max_hasil_ujian", 
      "min_hasil_praktek", "max_hasil_praktek"
    ];
    sheet.appendRow(headers);
    sheet.getRange("A1:F1").setFontWeight("bold");
    sheet.setFrozenRows(1);
  } else {
    // Migrasi otomatis jika header lama ditemukan
    const headerMin = sheet.getRange(1, 3).getValue();
    if (headerMin === "min_hasil_katrol") {
      Logger.log(`Memigrasi skema ${sheetName}...`);
      // Ganti nama header lama
      sheet.getRange(1, 3).setValue("min_hasil_ujian");
      sheet.getRange(1, 4).setValue("max_hasil_ujian");
      
      // Tambah header baru
      sheet.getRange(1, 5).setValue("min_hasil_praktek");
      sheet.getRange(1, 6).setValue("max_hasil_praktek");
      
      // Salin nilai Min/Maks lama ke kolom Praktek sebagai default
      const lastRow = sheet.getLastRow();
      if (lastRow > 1) {
        const minValues = sheet.getRange(2, 3, lastRow - 1, 1).getValues();
        const maxValues = sheet.getRange(2, 4, lastRow - 1, 1).getValues();
        sheet.getRange(2, 5, lastRow - 1, 1).setValues(minValues); // Salin Min
        sheet.getRange(2, 6, lastRow - 1, 1).setValues(maxValues); // Salin Maks
      }
      Logger.log(`Migrasi ${sheetName} selesai.`);
    }
  }
  return sheet;
}

// TAMBAHKAN FUNGSI INI di aplikasi2/Kode.gs.html

/**
 * [FUNGSI MANUAL SEKALI JALAN]
 * Untuk mengenkripsi semua password guru yang masih plain text di db_guru.
 * JALANKAN INI DARI EDITOR APLIKASI 2.
 */
function MIGRASI_PasswordGuru_Global() {
  Logger.log("Memulai migrasi password guru global...");
  
  const sheet = GURU_SHEET; // GURU_SHEET sudah didefinisikan di atas
  if (!sheet) {
    Logger.log("Sheet 'db_guru' tidak ditemukan. Batal.");
    return;
  }

  const range = sheet.getDataRange();
  const values = range.getValues();
  let migratedCount = 0;
  
  // Mulai dari i = 1 untuk melewati header
  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    const plainOrHashPass = row[1]; // Kolom B (HashedPassword)
    const salt = row[5];            // Kolom F (Salt)
    
    // Jika 'salt' KOSONG dan 'plainOrHashPass' ADA ISINYA,
    // kita anggap itu adalah password plain text yang perlu dimigrasi.
    if (plainOrHashPass && !salt) {
      try {
        const newSalt = generateSalt();
        const newHash = hashPassword(plainOrHashPass, newSalt); // plainOrHashPass = password lama
        
        // Update HashedPassword (Kolom B)
        sheet.getRange(i + 1, 2).setValue(newHash);
        // Update Salt (Kolom F)
        sheet.getRange(i + 1, 6).setValue(newSalt);
        
        migratedCount++;
        Logger.log(`Password untuk baris ${i+1} (Email: ${row[0]}) telah di-hash.`);
      } catch (e) {
         Logger.log(`Gagal hash baris ${i+1} (Email: ${row[0]}): ${e.message}`);
      }
    }
  }
  
  if (migratedCount > 0) {
    Logger.log(`Migrasi Selesai. ${migratedCount} password guru telah di-hash.`);
    SpreadsheetApp.flush();
    Browser.msgBox(`Migrasi Selesai. ${migratedCount} password guru telah di-hash.`);
  } else {
    Logger.log("Migrasi Selesai. Tidak ada password plain text yang ditemukan untuk dimigrasi.");
    Browser.msgBox("Migrasi Selesai. Tidak ada password lama yang ditemukan.");
  }
}

function _getSekolahDB_IDs(id_sekolah) {
  try {
    const masterSS = SpreadsheetApp.openById(ID_MASTER_SHEET_APLIKASI_1);
    const sheetSekolah = masterSS.getSheetByName('Sheet_Sekolah');
    if (!sheetSekolah) {
      throw new Error("Sheet_Sekolah di Master (App 1) tidak ditemukan.");
    }
    
    const data = sheetSekolah.getRange("A2:M" + sheetSekolah.getLastRow()).getValues(); 
    
    for (const row of data) {
      if (row[0] == id_sekolah) { // Kolom A (index 0)
        const app1_db_id = row[5]; // Kolom F (index 5)
        const app2_db_id = row[12]; // Kolom M (index 12)
        
        if (!app1_db_id) {
          throw new Error(`Database Aplikasi 1 (Kolom F) untuk sekolah ${id_sekolah} kosong di Master Sheet.`);
        }
        if (!app2_db_id) {
           // Di Aplikasi 2, kita tidak bisa memperbaiki ini. Kita harus melempar error.
           throw new Error(`Database Aplikasi 2 (Kolom M) untuk sekolah ${id_sekolah} kosong di Master Sheet. Harap hubungi Superadmin.`);
        }
        
        return { app1_db_id: app1_db_id, app2_db_id: app2_db_id };
      }
    }
    
    throw new Error(`ID Sekolah ${id_sekolah} tidak ditemukan di Master Sheet.`);
    
  } catch (e) {
    Logger.log(`Error Kritis di _getSekolahDB_IDs (App 2): ${e.message}`);
    throw e; // Lemparkan error
  }
}

/**
 * [BARU] Helper untuk konversi angka Romawi (hingga 39, cukup untuk kelas).
 * Ditambahkan di server untuk sorting.
 */
function romanToInt(s) {
  if (!s) return 0;
  const map = { 'I': 1, 'V': 5, 'X': 10 };
  let num = 0;
  try {
    for (let i = 0; i < s.length; i++) {
      const curr = map[s[i].toUpperCase()];
      const next = map[s[i+1] ? s[i+1].toUpperCase() : null]; // Perbaikan: Cek 'next'
      if (curr < next) {
        num -= curr;
      } else {
        num += curr;
      }
    }
  } catch(e) { return 0; }
  return num;
}

/**
 * [BARU] Helper untuk mengekstrak nilai sortable dari nama kelas.
 * Ditambahkan di server untuk sorting.
 */
function getKelasSortValue(className) {
  if (!className) return { type: 'string', value: 999, original: '' };
  
  // Regex untuk Romawi (sebagai kata utuh, misal "VI" tapi bukan "VIP")
  const romanMatch = className.toUpperCase().match(/\b(XII|XI|X|IX|VIII|VII|VI|V|IV|III|II|I)\b/);
  if (romanMatch) {
    return { 
      type: 'number', 
      value: romanToInt(romanMatch[0]), 
      original: className 
    };
  }
  
  // Regex untuk angka Arab
  const arabicMatch = className.match(/(\d+)/);
  if (arabicMatch) {
    return { 
      type: 'number', 
      value: parseInt(arabicMatch[0], 10), 
      original: className 
    };
  }
  
  // Tidak ada angka, urutkan berdasarkan abjad
  return { type: 'string', value: 999, original: className };
}

/**
 * [BARU] Fungsi komparator untuk sorting nama kelas.
 * Ditambahkan di server untuk sorting.
 */
function compareKelas(a, b) {
  const valA = getKelasSortValue(a);
  const valB = getKelasSortValue(b);

  // Angka (Romawi/Arab) selalu di atas string
  if (valA.type === 'number' && valB.type === 'string') return -1;
  if (valA.type === 'string' && valB.type === 'number') return 1;

  // Jika keduanya angka
  if (valA.type === 'number' && valB.type === 'number') {
    if (valA.value !== valB.value) {
      return valA.value - valB.value; // Urutkan berdasarkan angkanya (1, 2, 6, 9, 10)
    }
  }
  
  // Jika keduanya string, atau angkanya sama (misal VI A vs VI B)
  // Urutkan berdasarkan teks aslinya
  return valA.original.localeCompare(b.original, undefined, { numeric: true, sensitivity: 'base' });
}

// --- [TAMBAHKAN DUA FUNGSI BARU INI] ---

/**
 * Memformat string gelar menjadi Proper Case.
 * Contoh: "s.pd.i" -> "S.Pd.I"
 * Contoh: "S.TR.T" -> "S.Tr.T"
 * Contoh: "s.e" -> "S.E"
 */
function properCaseGelar(gelarString) {
  if (!gelarString) return '';
  
  return gelarString.split(' ') // 1. Pisah antar gelar (e.g., "S.Pd M.Pd")
    .map(gelarPart => {
      
      return gelarPart.split('.') // 2. Pisah per titik (e.g., "s", "pd", "i")
        .map(subPart => {
          if (subPart.length === 0) return ''; // Menangani '..'
          
          // Jika sudah UPPERCASE (misal: S, TR, T), biarkan.
          if (subPart === subPart.toUpperCase()) return subPart; 
          
          // Jika lowercase (misal: s, pd, i)
          if (subPart.length === 1) return subPart.toUpperCase(); // s -> S, i -> I
          
          // Jika mixed/lower (misal: pd, Tr)
          return subPart.charAt(0).toUpperCase() + subPart.slice(1).toLowerCase(); // pd -> Pd
        })
        .join('.'); // 3. Gabungkan kembali dengan titik
        
    })
    .join(' '); // 4. Gabungkan kembali dengan spasi
}

/**
 * Memformat nama lengkap menjadi NAMA KAPITAL, Gelar.Proper.
 * Akan mencoba menebak gelar jika tidak ada koma.
 */
function formatNamaGelar(namaLengkap) {
  if (!namaLengkap) return '';
  namaLengkap = namaLengkap.trim();
  
  let nama = '';
  let gelar = '';
  
  const commaIndex = namaLengkap.indexOf(',');
  
  if (commaIndex > -1) {
    // KASUS 1: Ada koma (e.g., "Asma, s.pd.i") - Paling Ideal
    nama = namaLengkap.substring(0, commaIndex).trim();
    gelar = namaLengkap.substring(commaIndex + 1).trim();
    
  } else {
    // KASUS 2: Tidak ada koma (e.g., "Asma S.pd.i") - Coba tebak
    const parts = namaLengkap.split(' ');
    if (parts.length < 2) return namaLengkap.toUpperCase(); // Hanya satu kata, kapitalkan semua
    
    let titleStartIndex = -1;
    
    // Cari bagian pertama yang terlihat seperti gelar (mulai dari kata KEDUA)
    for (let i = 1; i < parts.length; i++) {
      const part = parts[i];
      // Asumsi gelar jika: mengandung titik (S.Pd) ATAU 1-3 huruf kapital (SE)
      if (part.includes('.') || (part.length >= 1 && part.length <= 3 && part === part.toUpperCase())) {
        titleStartIndex = i;
        break;
      }
    }

    if (titleStartIndex > -1) {
      // Ditemukan gelar
      nama = parts.slice(0, titleStartIndex).join(' ');
      gelar = parts.slice(titleStartIndex).join(' ');
    } else {
      // Tidak ditemukan gelar, kapitalkan semua
      nama = namaLengkap;
      gelar = '';
    }
  }

  // Format dan gabungkan kembali
  if (gelar) {
    return nama.toUpperCase() + ', ' + properCaseGelar(gelar);
  } else {
    return nama.toUpperCase();
  }
}
// --- [AKHIR FUNGSI BARU] ---

function getStatusKirimSheet(ss_sekolah) {
  const sheetName = 'db_status_kirim';
  let sheet = ss_sekolah.getSheetByName(sheetName);

  if (!sheet) {
    sheet = ss_sekolah.insertSheet(sheetName);
    const headers = [
      "key", "id_tahun_ajaran", "email_guru", "nama_mapel", 
      "timestamp_kirim", "tanggal_ttd", "status_approval", "alasan_tolak"
    ];
    sheet.appendRow(headers);
    sheet.getRange("A1:H1").setFontWeight("bold");
    sheet.setFrozenRows(1);
  } else {
    const headerStatus = sheet.getRange(1, 7).getValue();
    if (headerStatus !== "status_approval") {
      sheet.getRange(1, 7).setValue("status_approval");
      sheet.getRange(1, 8).setValue("alasan_tolak");
    }
  }
  return sheet;
}

/**
 * [BARU] Helper untuk mengirim email HTML dari Aplikasi 2.
 */
function _sendEmailApp2(to, subject, htmlBody) {
  try {
    if (!to) return;
    MailApp.sendEmail({
      to: to,
      subject: subject,
      htmlBody: htmlBody,
      name: "Sistem Nilai Ujian" // Nama pengirim
    });
    Logger.log(`Email notifikasi terkirim ke ${to}`);
  } catch (e) {
    Logger.log(`Gagal mengirim email ke ${to}: ${e.message}`);
  }
}

/**
 * [BARU] Mengambil Email Admin Sekolah dari Master Sheet (App 1) berdasarkan ID Sekolah.
 */
function _getAdminEmailFromMaster(id_sekolah) {
  try {
    const masterSS = SpreadsheetApp.openById(ID_MASTER_SHEET_APLIKASI_1);
    const sheetSekolah = masterSS.getSheetByName('Sheet_Sekolah');
    
    // Kita hanya perlu kolom A (ID) dan D (Email Admin)
    // Asumsi: data sekolah tidak akan jutaan baris, jadi getValues() masih aman
    const data = sheetSekolah.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][0] == id_sekolah) { // Kolom A
        return data[i][3]; // Kolom D (Email Admin)
      }
    }
    return null;
  } catch (e) {
    Logger.log("Gagal mengambil email admin: " + e.message);
    return null;
  }
}

function getCachedSiswaData(ss_sekolah) {
  // 1. Ambil Versi Data Terbaru dari Spreadsheet (Cek Z1)
  const dataVersion = _getDataVersion(ss_sekolah);
  
  // 2. Masukkan Versi ke dalam Key Cache
  // Jika Admin update di App 1, Z1 berubah -> Key berubah -> Cache Miss -> Ambil Data Baru
  const cacheKey = 'CACHE_DB_SISWA_' + ss_sekolah.getId() + '_' + dataVersion;
  
  const cache = CacheService.getScriptCache();
  const cached = cache.get(cacheKey);
  
  if (cached) {
    // Cache Hit: Data di memori masih valid (Z1 belum berubah)
    return JSON.parse(cached);
  }
  
  // Cache Miss: Data berubah (Z1 baru) atau expired
  const sheetSiswa = ss_sekolah.getSheetByName('db_siswa');
  if (!sheetSiswa) return [];

  const data = sheetSiswa.getDataRange().getValues().slice(1); 
  
  const minimizedData = data.map((row, index) => ({
    no: String(row[0]), 
    nama: row[1],       
    nisn: row[2] || '-',
    kelas: row[3] || 'N/A', 
    idx: index          
  }));
  
  try {
    // Simpan ke cache baru
    cache.put(cacheKey, JSON.stringify(minimizedData), 1200); 
  } catch(e) {
    Logger.log("Data siswa terlalu besar untuk cache.");
  }
  
  return minimizedData;
}

function getCachedMapelDb(ss_sekolah) {
  // 1. Ambil Versi Data
  const dataVersion = _getDataVersion(ss_sekolah);
  
  // 2. Gunakan Versi di Key
  const cacheKey = 'CACHE_DB_MAPEL_FULL_' + ss_sekolah.getId() + '_' + dataVersion;
  
  const cache = CacheService.getScriptCache();
  const cached = cache.get(cacheKey);
  
  if (cached) {
    return JSON.parse(cached);
  }
  
  const sheet = ss_sekolah.getSheetByName('db_mapel');
  if (!sheet) return [];

  const data = sheet.getDataRange().getValues().slice(1);
  
  const mappedData = data.map(row => ({
    email: String(row[0]).toLowerCase(),
    mapel: row[1],
    ta: String(row[2]),
    kelasJson: row[4] || '["*"]', 
    isUS: row[5] === true,
    isUP: row[6] === true
  }));
  
  try {
    cache.put(cacheKey, JSON.stringify(mappedData), 1200); 
  } catch(e) {}
  
  return mappedData;
}

/**
 * [HELPER BARU] Mengubah blob gambar menjadi Data URL Base64.
 * Diperlukan untuk menampilkan Kop Surat di PDF.
 */
function _getImageAsBase64DataUrl(fileId) {
  try {
    if (!fileId) return null;
    const file = DriveApp.getFileById(fileId);
    const blob = file.getBlob();
    const contentType = blob.getContentType();
    
    // Pastikan ini adalah gambar
    if (!contentType || !contentType.startsWith('image/')) {
      Logger.log(`File ID ${fileId} bukan gambar, tapi ${contentType}.`);
      return null;
    }
    
    const base64Data = Utilities.base64Encode(blob.getBytes());
    return `data:${contentType};base64,${base64Data}`;
    
  } catch (e) {
    Logger.log(`Gagal mengonversi gambar (ID: ${fileId}) ke Base64. Error: ${e.message}`);
    return null; // Gagal, kembalikan null
  }
}

/**
 * [MIGRASI APP 2] Tambah Kolom 'id_tahun_ajaran' di db_guru (Kolom H / Index 8)
 * Jalankan fungsi ini SEKALI secara manual.
 */
function _MIGRASI_TambahKolomTAGuru() {
  const ss = SpreadsheetApp.openById(ID_SPREADSHEET_APLIKASI_2);
  const sheet = ss.getSheetByName('db_guru');
  // Header saat ini (A-G): Email, Hash, Nama, Sekolah, Role, Salt, NIP
  // Kita tambah di Kolom H
  const header = sheet.getRange("H1").getValue();
  if (header !== "id_tahun_ajaran") {
    sheet.getRange("H1").setValue("id_tahun_ajaran");
    Logger.log("Kolom id_tahun_ajaran berhasil ditambahkan ke db_guru.");
  } else {
    Logger.log("Kolom id_tahun_ajaran sudah ada.");
  }
}

/**
 * [BARU] Menyimpan Tahun Ajaran Aktif untuk Guru di DB Global
 */
function updateGuruActiveTA_Global(email, taId) {
  const lock = LockService.getScriptLock();
  lock.waitLock(10000);
  try {
    const ss = SpreadsheetApp.openById(ID_SPREADSHEET_APLIKASI_2);
    const sheet = ss.getSheetByName('db_guru');
    const data = sheet.getDataRange().getValues();
    
    let found = false;
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]).toLowerCase() === email.toLowerCase()) {
        // Kolom H adalah index 7 (0-based) -> tapi getRange 1-based jadi kolom 8
        sheet.getRange(i + 1, 8).setValue(taId);
        found = true;
        break;
      }
    }
    
    if (!found) throw new Error("Guru tidak ditemukan di DB Global.");
    return { status: "sukses" };
    
  } catch (e) {
    return { status: "gagal", message: e.message };
  } finally {
    lock.releaseLock();
  }
}

/**
 * [BARU] Mengambil Versi Data (Timestamp) dari Sheet db_sekolah cell Z1.
 * Ini sangat cepat karena hanya membaca 1 cell.
 */
function _getDataVersion(ss) {
  try {
    const sheet = ss.getSheetByName('db_sekolah');
    if (!sheet) return 'v1';
    // Baca Z1. Jika kosong, return string default.
    const version = sheet.getRange('Z1').getValue(); 
    return version || 'v1';
  } catch (e) {
    return 'v1';
  }
}

/**
 * [DIPERBARUI] Membaca Pengaturan Izin Input dari DB Aplikasi 1
 * Menyusun pesan pengumuman sesuai skenario waktu.
 */
function _getIzinInputDariApp1(app1_db_id) {
  const cache = CacheService.getScriptCache();
  const cacheKey = 'IZIN_INPUT_APP1_V2_' + app1_db_id; // Ganti key agar cache lama tidak bentrok
  const cached = cache.get(cacheKey);
  
  if (cached) {
    return JSON.parse(cached);
  }
  
  try {
    const ss_app1 = SpreadsheetApp.openById(app1_db_id);
    const sheetPengaturan = ss_app1.getSheetByName('Pengaturan');
    if (!sheetPengaturan) return { canSave: true, canSend: true, pesan: "" };

    const data = sheetPengaturan.getRange("A1:B" + sheetPengaturan.getLastRow()).getValues();
    
    let isAktif = false; 
    let tglMulai = null;
    let tglTutup = null;

    for (let i = 0; i < data.length; i++) {
      if (data[i][0] === 'Guru_Input_Aktif') isAktif = (data[i][1] === true);
      else if (data[i][0] === 'Guru_Input_Mulai' && data[i][1] instanceof Date) tglMulai = data[i][1];
      else if (data[i][0] === 'Guru_Input_Tutup' && data[i][1] instanceof Date) tglTutup = data[i][1];
    }

    const result = { canSave: true, canSend: true, pesan: "", statusColor: "success" };
    const now = new Date();
    const timeZone = Session.getScriptTimeZone();
    const formatStr = "dd MMMM yyyy HH:mm"; // Format tanggal: 24 November 2025 14:00

    if (!isAktif) {
      // SKENARIO: ADMIN MENONAKTIFKAN (Toggle OFF)
      result.canSend = false;
      result.pesan = "Fitur kirim nilai sedang ditutup oleh Admin.";
      result.statusColor = "danger"; // Merah
    } else {
      // SKENARIO: ADMIN MENGAKTIFKAN (Toggle ON)
      
      // Format tanggal untuk pesan
      const startStr = tglMulai ? Utilities.formatDate(tglMulai, timeZone, formatStr) : "";
      const endStr = tglTutup ? Utilities.formatDate(tglTutup, timeZone, formatStr) : "";

      // 1. Jika tidak ditetapkan waktu atau tanggalnya dikosongkan
      if (!tglMulai && !tglTutup) {
         result.canSend = true;
         result.pesan = "Pengiriman nilai telah dibuka.";
         result.statusColor = "success"; // Hijau
      }
      
      // 2. Jika hanya mengisi Tanggal Mulai Input
      else if (tglMulai && !tglTutup) {
         if (now < tglMulai) {
            // Belum waktunya
            result.canSend = false;
            result.pesan = `Pengiriman nilai belum dibuka. Akan dibuka mulai tanggal ${startStr}.`;
            result.statusColor = "warning"; // Kuning
         } else {
            // Sudah lewat waktu mulai
            result.canSend = true;
            result.pesan = `Pengiriman nilai bisa dilakukan mulai tanggal ${startStr}.`;
            result.statusColor = "success"; 
         }
      }
      
      // 3. Jika hanya mengisi Tanggal Selesai Input
      else if (!tglMulai && tglTutup) {
         if (now > tglTutup) {
            // Sudah lewat waktu tutup
            result.canSend = false;
            result.pesan = `Pengiriman nilai telah ditutup pada tanggal ${endStr}.`;
            result.statusColor = "danger"; 
         } else {
            // Masih bisa
            result.canSend = true;
            result.pesan = `Pengiriman nilai dibuka dan akan ditutup tanggal ${endStr}.`;
            result.statusColor = "warning"; // Kuning (Warning deadline)
         }
      }
      
      // 4. Jika Tanggal Mulai dan Tanggal Selesai diisi
      else if (tglMulai && tglTutup) {
         if (now < tglMulai) {
            result.canSend = false;
            result.pesan = `Pengiriman nilai belum dibuka. Dapat dilakukan tanggal ${startStr} dan akan ditutup tanggal ${endStr}.`;
            result.statusColor = "warning";
         } else if (now > tglTutup) {
            result.canSend = false;
            result.pesan = `Pengiriman nilai telah ditutup (Periode: ${startStr} s.d. ${endStr}).`;
            result.statusColor = "danger";
         } else {
            result.canSend = true;
            result.pesan = `Pengiriman nilai dapat dilakukan tanggal ${startStr} dan akan ditutup tanggal ${endStr}.`;
            result.statusColor = "success"; // Atau info
         }
      }
    }

    // Cache sebentar (1 menit) agar responsif jika admin mengubah setting
    cache.put(cacheKey, JSON.stringify(result), 60);
    return result;

  } catch (e) {
    Logger.log("Gagal baca izin App 1: " + e.message);
    return { canSave: true, canSend: true, pesan: "", statusColor: "info" };
  }
}

/**
 * [TEROPTIMASI] Fungsi Ringan untuk Polling Status Realtime dengan Cache.
 * Menggunakan CacheService untuk mengurangi beban pembacaan Spreadsheet.
 */
function getLatestMapelStatus(token) {
  try {
    // 1. Validasi Sesi Ringan
    const session = _getVerifiedSessionData(token, 'guru');
    const email = session.email.toLowerCase();
    
    // --- OPTIMASI CACHE DIMULAI DI SINI ---
    const cache = CacheService.getScriptCache();
    const cacheKey = 'REALTIME_STATUS_' + email; // Key unik per guru
    const cachedData = cache.get(cacheKey);

    // Jika data ada di cache, kembalikan langsung (Hemat Kuota Read)
    if (cachedData) {
      return { status: 'sukses', data: JSON.parse(cachedData), source: 'cache' };
    }
    // ---------------------------------------
    
    // 2. Jika Cache Kosong, Buka Spreadsheet
    const ss = session.ss_sekolah; 
    const statusSheet = getStatusKirimSheet(ss);
    
    // 3. Ambil Data (Operasi Berat)
    const data = statusSheet.getDataRange().getValues(); 
    
    const statusMap = {};
    
    // Loop data status
    for (let i = 1; i < data.length; i++) {
      const rowEmail = String(data[i][2]).toLowerCase();
      const idTA = data[i][1];
      const mapel = data[i][3];
      const status = data[i][6]; // Kolom G

      // Filter hanya milik guru ini
      if (rowEmail === email) {
        if (!statusMap[idTA]) statusMap[idTA] = {};
        statusMap[idTA][mapel] = status;
      }
    }
    
    // 4. Simpan Hasil ke Cache selama 15 detik
    // Artinya, data hanya akan diperbarui dari sheet maksimal 4x per menit,
    // meskipun polling klien berjalan setiap 5 detik.
    cache.put(cacheKey, JSON.stringify(statusMap), 15); 
    
    return { status: 'sukses', data: statusMap, source: 'sheet' };

  } catch (e) {
    return { status: 'gagal', error: e.toString() };
  }
}
